#include <WiFi.h>           // WLAN-Bibliothek für ESP32
#include <HTTPClient.h>     // HTTP-Client für Anfragen
#include <Wire.h>           // Für I2C-Kommunikation
#include <Adafruit_VL53L0X.h> // VL53L0X Sensor-Bibliothek
#include <Preferences.h>    // Für NVS-Speicherung (nicht-flüchtiger Speicher)
#include <WiFiManager.h>    // Für Captive Portal zur WLAN-Einrichtung
#include <vector>           // Für dynamische Arrays (std::vector)
#include <numeric>          // Für std::accumulate
#include <Update.h>         // Für OTA (Over-The-Air) Updates
#include <ArduinoJson.h>    // Zum Parsen von JSON-Daten

// ---------------------- Konfiguration ---------------------- //

// Server-Endpunkte (Briefkasten-Backend)
const char* registrationServerUrl = "http://45.195.250.247:8002/device";
const char* calibrationServerUrl  = "http://45.195.250.247:8002/calibration";
const char* letterServerUrl       = "http://45.195.250.247:8002/letter";
const char* doorServerUrl         = "http://45.195.250.247:8002/door";
const char* keepaliveServerUrl    = "http://45.195.250.247:8002/keepalive";

// OTA-Server für Firmware:
const char* ota_host = "http://45.195.250.247:8008";
#define CURRENT_FIRMWARE_VERSION "1.0.2" // <-- WICHTIG: Ihre aktuelle Version hier eintragen!

// Ping-Intervall für OTA-Dashboard (hier 1 Minute) – nur relevant in loop(), falls kein Deep Sleep verwendet wird
unsigned long lastPingTime = 0;
unsigned long pingInterval = 60000; // 1 Minute in ms

// Pin-Definitionen
#define PIR_PIN 27          // GPIO-Pin, an dem der PIR-Sensor angeschlossen ist
#define LED_PIN 2           // GPIO-Pin für die eingebaute Status-LED (optional)
#define RESET_BUTTON_PIN 0  // GPIO-Pin für den Reset-Taster (oft GPIO0 für Boot-Modus)

// Globale Variablen für Kalibrierungswerte
int minDistance = 0; // Minimale Distanz (Kalibrierung)
int maxDistance = 0; // Maximale Distanz (Kalibrierung)

// Globale Variablen für Keep-Alive Timing
unsigned long lastKeepAlive = 0; // Zeitstempel des letzten Keep-Alive Signals
const unsigned long keepAliveInterval = 15 * 60 * 1000; // 15 Minuten in Millisekunden

// VL53L0X Instanz (Distanzsensor)
Adafruit_VL53L0X lox;

// Preferences Instanz (für NVS)
Preferences preferences;

// --------------------------------------------------------------
// Funktionsprototypen
// --------------------------------------------------------------
void connectToWiFi();
bool isResetButtonPressed();
void sendPing(); // OTA Ping mit detailliertem Logging
void checkDeviceFirmware(); // OTA Check mit detailliertem Logging
void performOTA(String firmwareUrl); // OTA Durchführung mit detailliertem Logging
void calibrateVL53L0X();
void measureForFiveSeconds();
void sendDeviceInfo();
void sendCalibrationData();
void sendLetterEvent(int distance);
void sendDoorEvent(int distance);
void sendKeepAlive();
void sendToServer(const char* serverUrl, String jsonPayload);
void configureDeepSleep();

// --------------------------------------------------------------
// W-LAN-Verbindung (WiFiManager + manuelles Verbinden)
// --------------------------------------------------------------
void connectToWiFi() {
  Serial.println("[WIFI] Prüfe WLAN-Status...");
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("[WIFI] Bereits verbunden. IP: %s, RSSI: %d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    return;
  }

  Serial.println("[WIFI] Versuche, eine Verbindung mit gespeicherten WLAN-Daten herzustellen...");
  WiFi.mode(WIFI_STA); // Sicherstellen, dass wir im Station-Modus sind
  WiFi.begin(); // Mit den gespeicherten WLAN-Daten verbinden

  int retries = 0;
  const int maxRetries = 20;
  const int retryDelay = 500;

  Serial.print("[WIFI] Verbindungsversuch ");
  while (WiFi.status() != WL_CONNECTED && retries < maxRetries) {
    delay(retryDelay);
    Serial.print(".");
    retries++;
  }
  Serial.println(); // Zeilenumbruch nach den Punkten

  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("[WIFI] Erfolgreich verbunden! IP-Adresse: %s, RSSI: %d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
  } else {
    Serial.printf("\n[WIFI] Verbindung nach %d Versuchen fehlgeschlagen! Status: %d. Starte erneuten Versuch...\n", retries, WiFi.status());
    WiFi.disconnect(true); // Alte Konfiguration löschen
    delay(100);
    WiFi.mode(WIFI_OFF); // WLAN aus
    delay(1000);
    WiFi.mode(WIFI_STA); // WLAN wieder an
    WiFi.begin();        // Erneuter Versuch mit gespeicherten Daten

    retries = 0;
    Serial.print("[WIFI] Erneuter Verbindungsversuch ");
    while (WiFi.status() != WL_CONNECTED && retries < maxRetries) {
      delay(retryDelay);
      Serial.print(".");
      retries++;
    }
    Serial.println(); // Zeilenumbruch

    if (WiFi.status() == WL_CONNECTED) {
      Serial.printf("[WIFI] Erfolgreich verbunden nach erneutem Versuch! IP-Adresse: %s, RSSI: %d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    } else {
      Serial.printf("[WIFI] Verbindung auch nach erneutem Versuch fehlgeschlagen! Status: %d\n", WiFi.status());
      // Hier könnte man überlegen, ob man den WiFiManager startet oder neu bootet
    }
  }
}

// --------------------------------------------------------------
// DETAILLIERTE OTA-FUNKTIONEN
// --------------------------------------------------------------

/**
 * Ping an den OTA-Server, damit das Gerät im Dashboard angezeigt wird.
 * Mit detailliertem Logging.
 */
void sendPing() {
  Serial.println("\n----- [OTA PING START] -----");
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[OTA PING] FEHLER: Keine WLAN-Verbindung.");
    Serial.println("----- [OTA PING ENDE] -----");
    return;
  }

  HTTPClient http;
  String url = String(ota_host) + "/ping";
  String mac = WiFi.macAddress();
  String firmwareVersion = String(CURRENT_FIRMWARE_VERSION);
  String body = "{\"mac\": \"" + mac + "\", \"version\": \"" + firmwareVersion + "\"}";

  Serial.printf("[OTA PING] Ziel-URL: %s\n", url.c_str());
  Serial.printf("[OTA PING] Sende Payload: %s\n", body.c_str());

  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  http.setConnectTimeout(5000); // 5 Sekunden Verbindungs-Timeout
  http.setTimeout(5000);      // 5 Sekunden Antwort-Timeout

  int httpCode = http.POST(body);

  if (httpCode > 0) {
    // Erfolg (HTTP Code 2xx oder 3xx)
    Serial.printf("[OTA PING] HTTP-Statuscode: %d\n", httpCode);
    String response = http.getString();
    Serial.printf("[OTA PING] Server-Antwort (%d Bytes): %s\n", response.length(), response.c_str());
    Serial.println("[OTA PING] Ping erfolgreich gesendet.");
  } else {
    // Fehler
    Serial.printf("[OTA PING] FEHLER: Ping fehlgeschlagen!\n");
    Serial.printf("[OTA PING] HTTP-Fehlercode: %d\n", httpCode); // z.B. -1 für Connection refused, -11 für Timeout
    Serial.printf("[OTA PING] Fehlerbeschreibung: %s\n", http.errorToString(httpCode).c_str());
  }

  http.end(); // Ressourcen freigeben
  Serial.println("----- [OTA PING ENDE] -----");
}

/**
 * Fragt /device_firmware.json?mac=<MAC> ab und prüft, ob eine neue Version zugewiesen ist.
 * Mit detailliertem Logging.
 */
void checkDeviceFirmware() {
  Serial.println("\n----- [OTA CHECK START] -----");
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[OTA CHECK] FEHLER: Keine WLAN-Verbindung.");
    Serial.println("----- [OTA CHECK ENDE] -----");
    return;
  }

  HTTPClient http;
  String mac = WiFi.macAddress();
  String url = String(ota_host) + "/device_firmware.json?mac=" + mac;
  Serial.printf("[OTA CHECK] Frage Firmware-Info ab von: %s\n", url.c_str());

  http.begin(url);
  http.setConnectTimeout(5000); // 5 Sekunden Verbindungs-Timeout
  http.setTimeout(7000);      // 7 Sekunden Antwort-Timeout (JSON kann etwas größer sein)

  int httpCode = http.GET();

  if (httpCode == 200) {
    // Erfolg - JSON erhalten
    String payload = http.getString();
    Serial.printf("[OTA CHECK] HTTP-Statuscode: %d (OK)\n", httpCode);
    Serial.printf("[OTA CHECK] Empfangene Payload (%d Bytes): %s\n", payload.length(), payload.c_str());

    // JSON parsen
    StaticJsonDocument<512> doc; // Größe anpassen, falls die JSON-Antwort größer ist
    DeserializationError error = deserializeJson(doc, payload);

    if (error) {
      // JSON Parsing Fehler
      Serial.print("[OTA CHECK] FEHLER: Konnte JSON nicht parsen! ");
      Serial.println(error.c_str());
    } else {
      // JSON erfolgreich geparsed
      const char* assignedVersion_cstr = doc["version"]; // Sicherer Zugriff
      const char* firmwareUrl_cstr = doc["url"];         // Sicherer Zugriff

      String assignedVersion = assignedVersion_cstr ? String(assignedVersion_cstr) : "";
      String firmwareUrl = firmwareUrl_cstr ? String(firmwareUrl_cstr) : "";

      Serial.printf("[OTA CHECK] Installierte Version: %s\n", CURRENT_FIRMWARE_VERSION);
      Serial.printf("[OTA CHECK] Vom Server zugewiesene Version: '%s'\n", assignedVersion.c_str());
      Serial.printf("[OTA CHECK] Vom Server bereitgestellte URL: '%s'\n", firmwareUrl.c_str());

      // Versionen vergleichen und prüfen ob URL vorhanden ist
      if (assignedVersion != "" && firmwareUrl != "" && assignedVersion != String(CURRENT_FIRMWARE_VERSION)) {
        Serial.println("[OTA CHECK] Entscheidung: Neue Firmware-Version erkannt! Starte OTA-Update...");
        performOTA(firmwareUrl); // Starte den Update-Prozess
      } else if (assignedVersion == String(CURRENT_FIRMWARE_VERSION)) {
        Serial.println("[OTA CHECK] Entscheidung: Installierte Firmware ist aktuell.");
      } else if (assignedVersion == "") {
          Serial.println("[OTA CHECK] Entscheidung: Keine Version vom Server zugewiesen.");
      } else if (firmwareUrl == "") {
          Serial.println("[OTA CHECK] Entscheidung: Version zugewiesen, aber keine URL vorhanden. Update nicht möglich.");
      } else {
          Serial.println("[OTA CHECK] Entscheidung: Unbekannter Zustand oder Firmware aktuell.");
      }
    }
  } else if (httpCode == 404) {
      Serial.printf("[OTA CHECK] HTTP-Statuscode: %d (Not Found)\n", httpCode);
      Serial.println("[OTA CHECK] Keine Firmware-Informationen für dieses Gerät (MAC) auf dem Server gefunden.");
      Serial.println("[OTA CHECK] Entscheidung: Kein Update möglich/nötig.");
  } else {
    // Anderer HTTP Fehler
    Serial.printf("[OTA CHECK] FEHLER: Konnte Firmware-Info nicht abrufen!\n");
    Serial.printf("[OTA CHECK] HTTP-Statuscode: %d\n", httpCode);
    Serial.printf("[OTA CHECK] Fehlerbeschreibung: %s\n", http.errorToString(httpCode).c_str());
    String responseBody = http.getString(); // Versuche, Fehlerdetails vom Server zu bekommen
    if (responseBody.length() > 0) {
        Serial.printf("[OTA CHECK] Server-Fehlerantwort: %s\n", responseBody.c_str());
    }
  }

  http.end(); // Ressourcen freigeben
  Serial.println("----- [OTA CHECK ENDE] -----");
}


/**
 * Lädt neue Firmware von firmwareUrl herunter und flasht sie.
 * Mit detailliertem Logging und delay(1) zur Stabilisierung.
 */
void performOTA(String firmwareUrl) {
  Serial.println("\n----- [OTA DO START] -----");
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[OTA DO] FEHLER: Keine WLAN-Verbindung.");
    Serial.println("----- [OTA DO ENDE] -----");
    return;
  }

  Serial.printf("[OTA DO] Starte Download von Firmware-URL: %s\n", firmwareUrl.c_str());

  // WiFiClient wird benötigt für Stream-Handling bei großen Downloads
  WiFiClient client;
  HTTPClient http;

  http.begin(client, firmwareUrl); // Wichtig: WiFiClient übergeben
  http.setConnectTimeout(8000);  // Längerer Timeout für Verbindungsaufbau zum FW-Server
  http.setTimeout(60000);       // Längerer Timeout für den gesamten Download (60s) -> Kann erhöht werden bei langsamer Verbindung

  int httpCode = http.GET();

  if (httpCode == 200) {
    // Firmware-Download erfolgreich gestartet
    Serial.printf("[OTA DO] HTTP-Statuscode: %d (OK)\n", httpCode);
    int contentLength = http.getSize(); // Gesamtgröße der Firmware holen
    Serial.printf("[OTA DO] Firmware-Größe laut Server: %d Bytes\n", contentLength);

    if (contentLength <= 0) {
      Serial.println("[OTA DO] FEHLER: Ungültige Firmware-Größe (<= 0) vom Server erhalten.");
      http.end();
      Serial.println("----- [OTA DO ENDE] -----");
      return;
    }

    // Update-Prozess starten
    bool canBegin = Update.begin(contentLength);
    if (!canBegin) {
      Serial.println("[OTA DO] FEHLER: Update.begin() fehlgeschlagen!");
      Serial.printf("[OTA DO] Update-Fehlercode: %d\n", Update.getError());
      Serial.printf("[OTA DO] Fehlerbeschreibung: %s\n", Update.errorString());
      Serial.println("[OTA DO] Mögliche Ursachen: Nicht genug Speicherplatz (Partition zu klein?), falsche Partitionstabelle.");
      http.end();
      Serial.println("----- [OTA DO ENDE] -----");
      return;
    }

    Serial.printf("[OTA DO] Update gestartet. Erwartete Größe: %d Bytes.\n", contentLength);
    Serial.println("[OTA DO] Starte Download und Flash...");

    // Stream für den Download holen
    WiFiClient& stream = http.getStream();
    uint8_t buff[1024]; // Puffer für Download-Chunks
    size_t written = 0; // Bereits geschriebene Bytes
    int lastPercent = -1; // Für Prozentanzeige

    unsigned long startTime = millis(); // Zeitmessung starten
    bool connectionLost = false; // Flag für Verbindungsverlust

    // Download-Schleife
    while (http.connected() && written < contentLength) {
      size_t available = stream.available(); // Wieviele Bytes sind im Empfangspuffer?
      if (available) {
        // Es sind Daten da, lesen und schreiben
        int len = stream.readBytes(buff, min(available, sizeof(buff)));
        if (len > 0) {
          size_t wrote = Update.write(buff, len); // In Flash schreiben
          if (wrote == len) {
             written += wrote; // Geschriebene Bytes zählen
          } else {
            Serial.printf("\n[OTA DO] FEHLER: Update.write() hat weniger Bytes geschrieben (%d) als gelesen (%d)!\n", wrote, len);
            Serial.printf("[OTA DO] Update-Fehlercode: %d - %s\n", Update.getError(), Update.errorString());
            Update.abort(); // Update abbrechen
            http.end();
            Serial.println("----- [OTA DO ENDE] -----");
            return;
          }
        } else {
           // Fehler beim Lesen vom Stream
           Serial.println("\n[OTA DO] FEHLER: stream.readBytes hat 0 oder weniger zurückgegeben.");
           delay(100); // Kurz warten
        }

        // Fortschritt anzeigen
        int percent = (written * 100) / contentLength;
        if (percent != lastPercent && percent % 5 == 0) { // Alle 5% ausgeben
          Serial.printf("[OTA DO] Fortschritt: %d%% (%d / %d Bytes)\n", percent, written, contentLength);
          lastPercent = percent;
        }
      } else {
        // Keine Daten verfügbar, kurz warten und dem WiFi-Stack Zeit geben
        delay(1); // <<--- HINZUGEFÜGT: Kleine Pause zur Stabilisierung
      }

      // Timeout-Check (falls http.connected() hängt)
      if(millis() - startTime > 120000) { // 2 Minuten Gesamt-Timeout für Download
          Serial.println("\n[OTA DO] FEHLER: Download-Timeout (> 120 Sekunden)!");
          Update.abort();
          http.end();
          Serial.println("----- [OTA DO ENDE] -----");
          return;
      }
    } // Ende while(http.connected() && written < contentLength)

    // Nach der Schleife prüfen, warum sie beendet wurde
    if (!http.connected() && written < contentLength) {
        Serial.println("\n[OTA DO] WARNUNG: HTTP-Verbindung wurde getrennt, bevor der Download abgeschlossen war!");
        connectionLost = true; // Markieren, dass die Verbindung verloren ging
    }

    unsigned long duration = millis() - startTime;
    Serial.printf("\n[OTA DO] Download & Flash beendet. Geschrieben: %d Bytes in %lu ms.\n", written, duration);

    // Prüfen ob alles geschrieben wurde
    if (written != contentLength) {
        Serial.printf("[OTA DO] FEHLER: Geschriebene Bytes (%d) entsprechen nicht der erwarteten Größe (%d)!\n", written, contentLength);
        if (connectionLost) {
            Serial.println("[OTA DO] Ursache: Wahrscheinlich Verbindungsabbruch während des Downloads.");
        }
        Update.abort(); // Update als fehlgeschlagen markieren
        http.end();
        Serial.println("----- [OTA DO ENDE] -----");
        return;
    }

    // Update abschließen
    Serial.println("[OTA DO] Versuche Update abzuschließen (Update.end)...");
    if (Update.end(true)) { // true = success
      Serial.println("[OTA DO] Update.end() erfolgreich.");
      if (Update.isFinished()) {
        Serial.println("[OTA DO] Update erfolgreich abgeschlossen! Starte ESP neu...");
        delay(200); // Kurze Pause damit die Log-Nachricht rausgeht
        ESP.restart(); // Neustart mit neuer Firmware
        // Code hiernach wird nicht mehr erreicht
      } else {
        Serial.println("[OTA DO] FEHLER: Update.end() war erfolgreich, aber Update.isFinished() ist false?! Update fehlgeschlagen.");
      }
    } else {
      Serial.println("[OTA DO] FEHLER: Update.end() fehlgeschlagen!");
      Serial.printf("[OTA DO] Update-Fehlercode: %d\n", Update.getError());
      Serial.printf("[OTA DO] Fehlerbeschreibung: %s\n", Update.errorString());
    }

  } else {
    // Fehler beim HTTP GET Request für die Firmware
    Serial.printf("[OTA DO] FEHLER: Firmware konnte nicht heruntergeladen werden!\n");
    Serial.printf("[OTA DO] HTTP-Statuscode: %d\n", httpCode);
    Serial.printf("[OTA DO] Fehlerbeschreibung: %s\n", http.errorToString(httpCode).c_str());
     String responseBody = http.getString(); // Versuche, Fehlerdetails vom Server zu bekommen
    if (responseBody.length() > 0) {
        Serial.printf("[OTA DO] Server-Fehlerantwort: %s\n", responseBody.c_str());
    }
  }

  http.end(); // Ressourcen freigeben (wird auch bei Fehlern erreicht)
  Serial.println("----- [OTA DO ENDE] -----");
}


// --------------------------------------------------------------
// SETUP - Wird einmal nach Boot/Reset/Wakeup ausgeführt
// --------------------------------------------------------------
void setup() {
  // Pins initialisieren
  pinMode(PIR_PIN, INPUT);       // PIR als Eingang
  pinMode(LED_PIN, OUTPUT);      // LED als Ausgang
  digitalWrite(LED_PIN, LOW);    // LED initial aus

  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP); // Reset-Taster als Eingang mit Pullup

  // Serielle Kommunikation starten (für Debugging/Logging)
  Serial.begin(115200);
  delay(500); // Kurze Pause, damit Serial bereit ist
  Serial.println("\n\n==========================================");
  Serial.println("[BOOT] ESP32 Briefkasten Monitor startet...");
  Serial.printf("[BOOT] Firmware Version: %s\n", CURRENT_FIRMWARE_VERSION);
  Serial.println("==========================================");

  // Preferences (NVS) initialisieren
  Serial.println("[NVS] Initialisiere Preferences 'briefkasten'...");
  preferences.begin("briefkasten", false); // false = read/write mode

  // WiFiManager initialisieren
  WiFiManager wifiManager;
  // wifiManager.setDebugOutput(true); // Optional: Mehr Debug-Ausgaben von WiFiManager

  // Prüfen, ob der Reset-Taster gedrückt wurde, um WLAN-Daten zu löschen
  bool resetWifi = isResetButtonPressed();
  if (resetWifi) {
    Serial.println("[WIFI] Reset-Taster erkannt -> Lösche gespeicherte WLAN-Daten.");
    wifiManager.resetSettings();
    Serial.println("[WIFI] WLAN-Daten gelöscht. Bitte neu konfigurieren (AP 'BriefkastenAP'). Neustart in 5s...");
    delay(5000);
    ESP.restart();
  }

  // Aufwachgrund ermitteln
  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
  Serial.printf("[BOOT] Aufwachgrund: %d - ", wakeup_reason);

  // Je nach Aufwachgrund unterschiedliche Aktionen ausführen
  // *** WICHTIG: Jeder Case MUSS in {} eingeschlossen sein, um Compiler-Fehler zu vermeiden ***
  switch(wakeup_reason) {
    case ESP_SLEEP_WAKEUP_EXT0 : { // <<--- Hinzugefügte Klammer für Scope
      // ================== WAKEUP DURCH PIR-SENSOR ==================
      Serial.println("PIR-Sensor (EXT0)");
      Serial.println("------------------------------------------");
      Serial.println("[PIR WAKEUP] Starte Ablauf für Bewegungserkennung...");

      // Gespeicherte Daten laden (MAC, Kalibrierung)
      // Variablen sind jetzt lokal für diesen Case-Block
      String macAddress = preferences.getString("mac_address", "Nicht gesetzt");
      // minDistance und maxDistance sind global, keine Neudeklaration nötig
      minDistance = preferences.getInt("minDistance", 0);
      maxDistance = preferences.getInt("maxDistance", 0);
      Serial.printf("[NVS] Geladene Daten: MAC=%s, MinDist=%d mm, MaxDist=%d mm\n", macAddress.c_str(), minDistance, maxDistance);

      // Prüfen, ob Kalibrierung vorhanden ist
      if (minDistance == 0 || maxDistance == 0) {
        Serial.println("[PIR WAKEUP] WARNUNG: Keine gültige Kalibrierung im NVS gefunden!");
        Serial.println("[PIR WAKEUP] -> Starte WLAN und Kalibrierung jetzt...");
        connectToWiFi(); // WLAN wird für die Kalibrierung (Senden der Daten) benötigt
        if (WiFi.status() == WL_CONNECTED) {
            calibrateVL53L0X(); // Sensor kalibrieren
            sendCalibrationData(); // Kalibrierungsdaten senden
        } else {
            Serial.println("[PIR WAKEUP] FEHLER: Keine WLAN-Verbindung, Kalibrierung nicht möglich.");
            // Ohne Kalibrierung ist Messung sinnlos -> Schlafen legen
            configureDeepSleep();
        }
      } else {
          Serial.println("[PIR WAKEUP] Gültige Kalibrierung vorhanden.");
          // Hier wird *KEIN* WLAN benötigt, wenn nur gemessen werden soll.
          // WLAN wird erst in measureForFiveSeconds -> sendEvent benötigt.
      }

      // KEIN OTA-CHECK bei PIR-Wakeup, um die Messung nicht zu verzögern!
      Serial.println("[PIR WAKEUP] Überspringe OTA-Check bei PIR-Aufwachen.");

      // Messung durchführen (WLAN wird bei Bedarf innerhalb dieser Funktion verbunden)
      measureForFiveSeconds();

      // In den Tiefschlaf gehen
      Serial.println("[PIR WAKEUP] Ablauf beendet.");
      configureDeepSleep();
      break;
    } // <<--- Hinzugefügte Klammer für Scope

    case ESP_SLEEP_WAKEUP_TIMER : { // <<--- Hinzugefügte Klammer für Scope
      // ================== WAKEUP DURCH TIMER (KeepAlive/OTA) ==================
      Serial.println("Timer");
      Serial.println("------------------------------------------");
      Serial.println("[TIMER WAKEUP] Starte Ablauf für KeepAlive und OTA-Check...");

      // MAC-Adresse laden (lokale Variable für diesen Block)
      String timerMacAddress = preferences.getString("mac_address", "Nicht gesetzt");
      Serial.printf("[NVS] Geladene MAC: %s\n", timerMacAddress.c_str());
      if (timerMacAddress == "Nicht gesetzt") {
          Serial.println("[TIMER WAKEUP] FEHLER: Keine MAC-Adresse im NVS gespeichert! Breche ab.");
          // Ohne MAC kein KeepAlive/OTA sinnvoll
          configureDeepSleep(); // Trotzdem schlafen legen
          break; // Wichtig: break hier, um nicht zum default zu fallen
      }

      // WLAN verbinden
      connectToWiFi();

      if (WiFi.status() == WL_CONNECTED) {
          // Nur wenn WLAN verbunden ist:
          sendPing();             // Gerät im OTA-Dashboard sichtbar machen
          checkDeviceFirmware();  // Auf neue Firmware prüfen (OTA wird ggf. hier gestartet)
          sendKeepAlive();        // KeepAlive-Signal an das Backend senden
      } else {
          Serial.println("[TIMER WAKEUP] FEHLER: Keine WLAN-Verbindung. Überspringe Ping, OTA-Check und KeepAlive.");
      }

      // In den Tiefschlaf gehen
      Serial.println("[TIMER WAKEUP] Ablauf beendet.");
      configureDeepSleep();
      break;
    } // <<--- Hinzugefügte Klammer für Scope

    default : { // <<--- Hinzugefügte Klammer für Scope
      // ================== NORMALER START (Power On / Reset) ==================
      Serial.println("Power On / Reset / Unbekannt");
      Serial.println("------------------------------------------");
      Serial.println("[NORMAL BOOT] Starte initialen Einrichtungsablauf...");

      // WLAN verbinden (mit WiFiManager Fallback)
      Serial.println("[WIFI] Starte WiFiManager autoConnect...");
      // Parameter: AP Name, AP Passwort (optional)
      if (!wifiManager.autoConnect("BriefkastenAP")) {
        Serial.println("[WIFI] FEHLER: autoConnect fehlgeschlagen / Timeout erreicht. Starte neu...");
        delay(3000);
        ESP.restart();
      }
      // An dieser Stelle sollte WLAN verbunden sein (entweder alte Credentials oder neue via AP)
      Serial.printf("[WIFI] Erfolgreich verbunden via WiFiManager/gespeicherte Daten. IP: %s\n", WiFi.localIP().toString().c_str());

      // Aktuelle MAC-Adresse holen und speichern/prüfen (lokale Variablen)
      String currentMac = WiFi.macAddress();
      Serial.printf("[INFO] Aktuelle MAC-Adresse des Geräts: %s\n", currentMac.c_str());
      String storedMac = preferences.getString("mac_address", "");
      if (storedMac == "" || storedMac != currentMac) {
          if (storedMac == "") {
              Serial.println("[NVS] Keine MAC-Adresse gespeichert. Speichere aktuelle MAC...");
          } else {
              Serial.printf("[NVS] WARNUNG: Gespeicherte MAC (%s) weicht von aktueller MAC (%s) ab. Aktualisiere...\n", storedMac.c_str(), currentMac.c_str());
          }
          preferences.putString("mac_address", currentMac);
      } else {
          Serial.println("[NVS] Gespeicherte MAC-Adresse ist aktuell.");
      }

      // Gerät beim Backend registrieren (oder Infos aktualisieren)
      sendDeviceInfo();

      // Sensor kalibrieren
      calibrateVL53L0X();

      // Kalibrierungsdaten an das Backend senden
      sendCalibrationData();

      // OTA-Check beim normalen Start durchführen
      Serial.println("[NORMAL BOOT] Führe initialen OTA-Check durch...");
      sendPing();             // Gerät im OTA-Dashboard sichtbar machen
      checkDeviceFirmware();  // Auf neue Firmware prüfen

      // In den Tiefschlaf gehen
      Serial.println("[NORMAL BOOT] Initialer Ablauf beendet.");
      configureDeepSleep();
      // Kein break am Ende von default nötig
    } // <<--- Hinzugefügte Klammer für Scope
  } // Ende switch(wakeup_reason)
}

// --------------------------------------------------------------
// LOOP - Wird kontinuierlich ausgeführt (aber hier durch Deep Sleep meist übersprungen)
// --------------------------------------------------------------
void loop() {
  // Dieser Loop wird in der aktuellen Konfiguration (mit configureDeepSleep am Ende von setup)
  // normalerweise nicht oft oder lange erreicht. Er wäre relevant, wenn man den Deep Sleep
  // weglässt oder nur unter bestimmten Bedingungen aktiviert.
  delay(1000);
}

// --------------------------------------------------------------
// HELFER-FUNKTIONEN (Kalibrierung, Messung, Events, NVS, etc.)
// --------------------------------------------------------------

/**
 * Prüft, ob der Reset-Taster für eine bestimmte Zeit gedrückt wird.
 */
bool isResetButtonPressed() {
  Serial.println("[BTN] Prüfe Reset-Taster (GPIO0)...");
  const unsigned long debounceTime = 2000; // 2 Sekunden gedrückt halten
  unsigned long pressedTime = 0;
  int pinState = digitalRead(RESET_BUTTON_PIN);

  if (pinState == LOW) { // Taster gedrückt (Pullup -> LOW)
    Serial.println("[BTN] Reset-Taster ist gedrückt. Warte auf Bestätigung...");
    pressedTime = millis();
    while (digitalRead(RESET_BUTTON_PIN) == LOW) {
      delay(50); // Kurze Pause
      if (millis() - pressedTime > debounceTime) {
        Serial.println("[BTN] Reset-Taster lange genug gedrückt -> Aktion auslösen (WiFi Reset).");
        return true; // Lange genug gedrückt
      }
    }
    Serial.println("[BTN] Reset-Taster wurde losgelassen (zu kurz gedrückt).");
    return false;
  } else {
    Serial.println("[BTN] Reset-Taster nicht gedrückt.");
    return false;
  }
}

/**
 * Führt eine Kalibrierung des VL53L0X Sensors durch.
 */
void calibrateVL53L0X() {
  Serial.println("\n----- [CALIB START] -----");
  Serial.println("[VL53] Initialisiere VL53L0X Sensor...");
  if (!lox.begin()) {
    Serial.println("[VL53] FEHLER: VL53L0X Init fehlgeschlagen! Prüfe Verkabelung und Adresse.");
    Serial.println("----- [CALIB ENDE] -----");
    return;
  }
  Serial.println("[VL53] VL53L0X erfolgreich initialisiert.");
  lox.setMeasurementTimingBudgetMicroSeconds(50000); // 50ms, Standard

  unsigned long startTime = millis();
  unsigned long duration = 3000; // 3 Sekunden kalibrieren
  int currentMin = 9999;
  int currentMax = 0;
  int validMeasurements = 0;

  Serial.printf("[CALIB] Messe Distanz für %lu ms zur Kalibrierung...\n", duration);
  while (millis() - startTime < duration) {
    VL53L0X_RangingMeasurementData_t measure;
    lox.rangingTest(&measure, false);
    if (measure.RangeStatus == 0 || measure.RangeStatus == 1 || measure.RangeStatus == 2) {
      int dist = measure.RangeMilliMeter;
      if (dist < currentMin && dist > 0) currentMin = dist;
      if (dist > currentMax) currentMax = dist;
      validMeasurements++;
    }
    delay(50);
  }

  Serial.printf("[CALIB] Kalibrierungsmessung beendet. %d gültige Messwerte erhalten.\n", validMeasurements);

  if (validMeasurements > 0 && currentMin < 9999 && currentMax > 0) {
    Serial.printf("[CALIB] Rohwerte: Min=%d mm, Max=%d mm\n", currentMin, currentMax);
    minDistance = currentMin - 15;
    maxDistance = currentMax + 15;
    if (minDistance < 0) minDistance = 0;
    Serial.printf("[CALIB] Berechnete Schwellen (mit Puffer): MinDist=%d mm, MaxDist=%d mm\n", minDistance, maxDistance);
    Serial.println("[NVS] Speichere Kalibrierungsdaten (minDistance, maxDistance)...");
    preferences.putInt("minDistance", minDistance);
    preferences.putInt("maxDistance", maxDistance);
    Serial.println("[NVS] Kalibrierungsdaten gespeichert.");
  } else {
    Serial.println("[CALIB] FEHLER: Keine gültigen Messwerte während der Kalibrierung erhalten!");
    minDistance = preferences.getInt("minDistance", 0);
    maxDistance = preferences.getInt("maxDistance", 0);
  }
  Serial.println("----- [CALIB ENDE] -----");
}

/**
 * Misst 5 Sekunden lang die Distanz und analysiert die Werte.
 */
void measureForFiveSeconds() {
  Serial.println("\n----- [MEAS START] -----");
  Serial.println("[VL53] Initialisiere VL53L0X Sensor für Messung...");
  if (!lox.begin()) {
    Serial.println("[VL53] FEHLER: VL53L0X Init fehlgeschlagen!");
    Serial.println("----- [MEAS ENDE] -----");
    return;
  }
  Serial.println("[VL53] VL53L0X erfolgreich initialisiert.");
  lox.setMeasurementTimingBudgetMicroSeconds(20000);
  Serial.println("[VL53] Timing Budget auf 20000 us gesetzt.");

  unsigned long startTime = millis();
  unsigned long duration = 5000;
  std::vector<int> distBuffer;

  Serial.printf("[MEAS] Messe Distanz für %lu ms...\n", duration);
  while (millis() - startTime < duration) {
    VL53L0X_RangingMeasurementData_t m;
    lox.rangingTest(&m, false);
    if (m.RangeStatus == 0 || m.RangeStatus == 1 || m.RangeStatus == 2) {
      distBuffer.push_back(m.RangeMilliMeter);
    }
    delay(20);
  }

  Serial.printf("[MEAS] Messung beendet. %d Messwerte gesammelt.\n", distBuffer.size());

  if (distBuffer.empty()) {
    Serial.println("[MEAS] FEHLER: Keine gültigen Messwerte im Puffer.");
    Serial.println("----- [MEAS ENDE] -----");
    return;
  }

  int minVal = *std::min_element(distBuffer.begin(), distBuffer.end());
  int maxVal = *std::max_element(distBuffer.begin(), distBuffer.end());
  long long sum = std::accumulate(distBuffer.begin(), distBuffer.end(), 0LL);
  int avgVal = static_cast<int>(sum / distBuffer.size());

  Serial.printf("[ANALYSE] Ergebnisse der 5s-Messung:\n");
  Serial.printf("  -> Min: %d mm\n", minVal);
  Serial.printf("  -> Max: %d mm\n", maxVal);
  Serial.printf("  -> Avg: %d mm\n", avgVal);

  minDistance = preferences.getInt("minDistance", 0);
  maxDistance = preferences.getInt("maxDistance", 0);
  Serial.printf("[ANALYSE] Vergleich mit Schwellen: MinGrenze=%d mm, MaxGrenze=%d mm\n", minDistance, maxDistance);

  bool briefErkannt    = (minVal < minDistance) && (minDistance > 0);
  bool kastenGeoeffnet = (maxVal > maxDistance) && (maxDistance > 0);

  if (kastenGeoeffnet) {
    Serial.printf("[EVENT] *** Briefkasten-Tür geöffnet erkannt! *** (Maximalwert %d mm > Schwelle %d mm)\n", maxVal, maxDistance);
    sendDoorEvent(maxVal);
  } else if (briefErkannt) {
    Serial.printf("[EVENT] *** Neuer Brief erkannt! *** (Minimalwert %d mm < Schwelle %d mm)\n", minVal, minDistance);
    sendLetterEvent(minVal);
  } else {
    Serial.println("[EVENT] Kein signifikantes Ereignis (Brief/Tür) erkannt.");
  }
  Serial.println("----- [MEAS ENDE] -----");
}


// --------------------------------------------------------------
// FUNKTIONEN ZUM SENDEN VON DATEN AN DEN SERVER
// --------------------------------------------------------------

/**
 * Sendet Geräteinformationen (MAC, Firmware-Version) an den Server.
 */
void sendDeviceInfo() {
  Serial.println("\n----- [SEND DEV INFO START] -----");
  String macAddress = preferences.getString("mac_address", "FEHLER:Nicht_Gesetzt");
  if (macAddress.startsWith("FEHLER")) {
       Serial.println("[SEND DEV INFO] FEHLER: Konnte MAC-Adresse nicht aus NVS laden.");
       Serial.println("----- [SEND DEV INFO ENDE] -----");
       return;
  }
  Serial.printf("[SEND DEV INFO] Sende Geräteinfo für MAC: %s, Firmware: %s\n", macAddress.c_str(), CURRENT_FIRMWARE_VERSION);
  StaticJsonDocument<128> doc;
  doc["mac_address"] = macAddress;
  doc["firmware_version"] = CURRENT_FIRMWARE_VERSION;
  String jsonPayload;
  serializeJson(doc, jsonPayload);
  sendToServer(registrationServerUrl, jsonPayload);
  Serial.println("----- [SEND DEV INFO ENDE] -----");
}

/**
 * Sendet die Kalibrierungsdaten (Min/Max Distanz) an den Server.
 */
void sendCalibrationData() {
  Serial.println("\n----- [SEND CALIB DATA START] -----");
  String macAddress = preferences.getString("mac_address", "FEHLER:Nicht_Gesetzt");
   if (macAddress.startsWith("FEHLER")) {
       Serial.println("[SEND CALIB DATA] FEHLER: Konnte MAC-Adresse nicht aus NVS laden.");
       Serial.println("----- [SEND CALIB DATA ENDE] -----");
       return;
  }
  minDistance = preferences.getInt("minDistance", 0);
  maxDistance = preferences.getInt("maxDistance", 0);
  Serial.printf("[SEND CALIB DATA] Sende Kalibrierungsdaten für MAC: %s (Min: %d, Max: %d)\n", macAddress.c_str(), minDistance, maxDistance);
  StaticJsonDocument<128> doc;
  doc["mac_address"] = macAddress;
  doc["min_distance"] = minDistance;
  doc["max_distance"] = maxDistance;
  String jsonPayload;
  serializeJson(doc, jsonPayload);
  sendToServer(calibrationServerUrl, jsonPayload);
  Serial.println("----- [SEND CALIB DATA ENDE] -----");
}

/**
 * Sendet ein "Brief erkannt" Event an den Server.
 */
void sendLetterEvent(int distance) {
  Serial.println("\n----- [SEND LETTER EVENT START] -----");
  String macAddress = preferences.getString("mac_address", "FEHLER:Nicht_Gesetzt");
   if (macAddress.startsWith("FEHLER")) {
       Serial.println("[SEND LETTER EVENT] FEHLER: Konnte MAC-Adresse nicht aus NVS laden.");
       Serial.println("----- [SEND LETTER EVENT ENDE] -----");
       return;
  }
  Serial.printf("[SEND LETTER EVENT] Sende 'Brief erkannt' für MAC: %s (Distanz: %d mm)\n", macAddress.c_str(), distance);
  StaticJsonDocument<128> doc;
  doc["mac_address"] = macAddress;
  doc["event"] = "letter_detected";
  doc["distance"] = distance;
  String jsonPayload;
  serializeJson(doc, jsonPayload);
  sendToServer(letterServerUrl, jsonPayload);
  Serial.println("----- [SEND LETTER EVENT ENDE] -----");
}

/**
 * Sendet ein "Tür geöffnet" Event an den Server.
 */
void sendDoorEvent(int distance) {
  Serial.println("\n----- [SEND DOOR EVENT START] -----");
  String macAddress = preferences.getString("mac_address", "FEHLER:Nicht_Gesetzt");
  if (macAddress.startsWith("FEHLER")) {
       Serial.println("[SEND DOOR EVENT] FEHLER: Konnte MAC-Adresse nicht aus NVS laden.");
       Serial.println("----- [SEND DOOR EVENT ENDE] -----");
       return;
  }
  Serial.printf("[SEND DOOR EVENT] Sende 'Tür geöffnet' für MAC: %s (Distanz: %d mm)\n", macAddress.c_str(), distance);
  StaticJsonDocument<128> doc;
  doc["mac_address"] = macAddress;
  doc["event"] = "door_opened";
  doc["distance"] = distance;
  String jsonPayload;
  serializeJson(doc, jsonPayload);
  sendToServer(doorServerUrl, jsonPayload);
  Serial.println("----- [SEND DOOR EVENT ENDE] -----");
}

/**
 * Sendet ein Keep-Alive Signal an den Server.
 */
void sendKeepAlive() {
  Serial.println("\n----- [SEND KEEPALIVE START] -----");
  String macAddress = preferences.getString("mac_address", "FEHLER:Nicht_Gesetzt");
  if (macAddress.startsWith("FEHLER")) {
       Serial.println("[SEND KEEPALIVE] FEHLER: Konnte MAC-Adresse nicht aus NVS laden.");
       Serial.println("----- [SEND KEEPALIVE ENDE] -----");
       return;
  }
  Serial.printf("[SEND KEEPALIVE] Sende KeepAlive für MAC: %s\n", macAddress.c_str());
  StaticJsonDocument<64> doc;
  doc["mac_address"] = macAddress;
  String jsonPayload;
  serializeJson(doc, jsonPayload);
  sendToServer(keepaliveServerUrl, jsonPayload);
  Serial.println("----- [SEND KEEPALIVE ENDE] -----");
}

/**
 * Zentrale Funktion zum Senden einer JSON-Payload per POST an einen Server.
 */
void sendToServer(const char* serverUrl, String jsonPayload) {
  Serial.println("--------------------------------------------");
  Serial.printf("[HTTP] Sende POST an: %s\n", serverUrl);
  Serial.printf("[HTTP] Payload: %s\n", jsonPayload.c_str());
  connectToWiFi(); // Prüft und verbindet bei Bedarf

  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");
    http.setConnectTimeout(5000);
    http.setTimeout(7000);
    int httpCode = http.POST(jsonPayload);

    if (httpCode > 0) {
      String response = http.getString();
      Serial.printf("[HTTP] Antwort-Code: %d\n", httpCode);
      Serial.printf("[HTTP] Antwort-Body (%d Bytes): %s\n", response.length(), response.c_str());
      if (httpCode >= 200 && httpCode < 300) {
          Serial.println("[HTTP] Anfrage erfolgreich verarbeitet.");
      } else {
          Serial.printf("[HTTP] WARNUNG: Server meldet Erfolgscode %d, aber außerhalb des 2xx-Bereichs.\n", httpCode);
      }
    } else {
      Serial.printf("[HTTP] FEHLER: Senden fehlgeschlagen!\n");
      Serial.printf("[HTTP] HTTP-Fehlercode: %d\n", httpCode);
      Serial.printf("[HTTP] Fehlerbeschreibung: %s\n", http.errorToString(httpCode).c_str());
    }
    http.end();
  } else {
    Serial.println("[HTTP] FEHLER: Keine WLAN-Verbindung -> Senden nicht möglich.");
  }
  Serial.println("--------------------------------------------");
}


// --------------------------------------------------------------
// DEEP SLEEP KONFIGURATION
// --------------------------------------------------------------
/**
 * Konfiguriert die Aufwachquellen (PIR-Sensor, Timer) und versetzt
 * den ESP32 in den Deep Sleep Modus.
 */
void configureDeepSleep() {
  Serial.println("\n----- [SLEEP START] -----");
  Serial.printf("[SLEEP] Aktiviere EXT0 Wakeup an GPIO %d (Pegel: HIGH)\n", PIR_PIN);
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_27, 1);

  uint64_t sleepTimeUs = (uint64_t)keepAliveInterval * 1000ULL;
  Serial.printf("[SLEEP] Aktiviere Timer Wakeup in %llu us (%lu ms / %.1f min)\n",
                sleepTimeUs, keepAliveInterval, (float)keepAliveInterval / 60000.0f);
  esp_sleep_enable_timer_wakeup(sleepTimeUs);

  Serial.println("[SLEEP] Konfiguration abgeschlossen. Gehe in 5 Sekunden schlafen...");
  delay(5000);

  Serial.println("==========================================");
  Serial.println("[SLEEP] Gute Nacht! Entering Deep Sleep NOW.");
  Serial.println("==========================================");
  Serial.flush();

  esp_deep_sleep_start();
}
