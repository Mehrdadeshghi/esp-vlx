#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include <Adafruit_VL53L0X.h>
#include <Preferences.h>
#include <WiFiManager.h>
#include <vector>
#include <numeric>
#include <Update.h>
#include <ArduinoJson.h>

// ---------------------- Konfiguration ---------------------- //

// Vorhandene Endpoints
const char* registrationServerUrl   = "http://45.195.250.247:8002/device";
const char* calibrationServerUrl    = "http://45.195.250.247:8002/calibration";
const char* letterServerUrl         = "http://45.195.250.247:8002/letter";
const char* doorServerUrl           = "http://45.195.250.247:8002/door";
const char* keepaliveServerUrl      = "http://45.195.250.247:8002/keepalive";

// **NEU**: zusätzliche Endpoints
const char* logsServerUrl           = "http://45.195.250.247:8002/logs";
const char* measurementsServerUrl   = "http://45.195.250.247:8002/measurements";

// OTA-Server
const char* ota_host                = "http://45.195.250.247:8008";
#define CURRENT_FIRMWARE_VERSION    "1.0.5"

// Zeitintervalle
unsigned long lastPingTime          = 0;
unsigned long pingInterval          = 60000;   // 1 Minute
unsigned long lastKeepAlive         = 0;
const unsigned long keepAliveInterval = 15 * 60 * 1000; // 15 Min

// Hardware-Pins
#define PIR_PIN 27
#define LED_PIN 2
#define RESET_BUTTON_PIN 0

// Kalibrierung
int minDistance = 0;
int maxDistance = 0;

// Log-Puffer – hier als simpler globaler String
String logsBuffer;

Adafruit_VL53L0X lox;
Preferences preferences;

// --------------------------------------------------------------
// Vorwärtsdeklarationen
// --------------------------------------------------------------
void connectToWiFi();
bool isResetButtonPressed();
void calibrateVL53L0X();
void sendToServer(const char* serverUrl, String jsonPayload);

void sendPing();
void checkDeviceFirmware();
void performOTA(String firmwareUrl);

void sendDeviceInfo();
void sendCalibrationData();
void sendLetterEvent(int distance);
void sendDoorEvent(int distance);
void sendKeepAlive();

void addLogEntry(const String &entry);
void sendLogs();

std::vector<int> collectMeasurementsForTenSeconds();
void sendMeasurements(const std::vector<int> &measurements);
void analyzeAndSendEvents(const std::vector<int> &distances);

void configureDeepSleep();

// --------------------------------------------------------------
// setup()
// --------------------------------------------------------------
void setup() {
  pinMode(PIR_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);

  Serial.begin(115200);
  delay(200);

  preferences.begin("briefkasten", false);

  // WiFiManager
  WiFiManager wifiManager;
  if (isResetButtonPressed()) {
    Serial.println("[INFO] Reset-Taster -> lösche gespeicherte WLAN-Daten.");
    wifiManager.resetSettings();
  }

  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();

  if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
    // PIR-Sensor: WLAN-Verbindung explizit herstellen vor der Messung
    Serial.println("[WAKEUP] PIR-Sensor");
    connectToWiFi();
    
    String macAddress = preferences.getString("mac_address", "Nicht gesetzt");
    minDistance = preferences.getInt("minDistance", 0);
    maxDistance = preferences.getInt("maxDistance", 0);
    Serial.printf("[INFO] MAC=%s, Min=%d, Max=%d\n", macAddress.c_str(), minDistance, maxDistance);

    if (minDistance == 0 || maxDistance == 0) {
      Serial.println("[ERROR] Keine Kalibrierung -> Kalibriere jetzt...");
      calibrateVL53L0X();
    }
    // 10s Messung + Senden
    std::vector<int> distances = collectMeasurementsForTenSeconds();
    if (!distances.empty()) {
      sendMeasurements(distances);
      analyzeAndSendEvents(distances);
    } else {
      addLogEntry("Keine Distanzwerte beim PIR-Wakeup.");
    }
    sendLogs();
    configureDeepSleep();

  } else if (wakeup_reason == ESP_SLEEP_WAKEUP_TIMER) {
    Serial.println("[WAKEUP] Timer (KeepAlive)");
    connectToWiFi();
    sendPing();
    checkDeviceFirmware();
    sendKeepAlive();
    sendLogs(); // Falls in der Zwischenzeit Logs gesammelt wurden
    configureDeepSleep();

  } else {
    // Erster Boot
    Serial.println("[BOOT] Normaler Start");
    if (!wifiManager.autoConnect("BriefkastenAP")) {
      Serial.println("[WIFI] Timeout -> Neustart");
      ESP.restart();
    }

    Serial.printf("[WIFI] IP=%s\n", WiFi.localIP().toString().c_str());
    String mac = WiFi.macAddress();
    Serial.printf("[INFO] MAC=%s\n", mac.c_str());

    // MAC in Preferences speichern
    if (!preferences.isKey("mac_address")) {
      preferences.putString("mac_address", mac);
    } else {
      String storedMac = preferences.getString("mac_address", "Nicht gesetzt");
      if (storedMac != mac) {
        preferences.putString("mac_address", mac);
        Serial.println("[WARNING] MAC aktualisiert.");
      }
    }

    sendDeviceInfo();
    calibrateVL53L0X();
    sendCalibrationData();

    // OTA
    sendPing();
    checkDeviceFirmware();

    // Logs evtl. schicken
    sendLogs();

    configureDeepSleep();
  }
}

// --------------------------------------------------------------
// loop()
// --------------------------------------------------------------
void loop() {
  if (millis() - lastPingTime > pingInterval) {
    sendPing();
    // checkDeviceFirmware(); // optional
    lastPingTime = millis();
  }

  if (millis() - lastKeepAlive > keepAliveInterval) {
    connectToWiFi();
    sendKeepAlive();
    lastKeepAlive = millis();
  }
}

// --------------------------------------------------------------
// WiFi + Reset-Taster
// --------------------------------------------------------------
void connectToWiFi() {
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("[WIFI] Bereits verbunden.");
    return;
  }
  Serial.println("[WIFI] Nutze gespeicherte WLAN-Daten...");
  WiFi.begin();
  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries++ < 20) {
    delay(500);
    Serial.print(".");
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("\n[WIFI] Verbunden! IP=%s\n", WiFi.localIP().toString().c_str());
  } else {
    Serial.println("\n[WIFI] Fehler, Neustart...");
    WiFi.disconnect();
    WiFi.mode(WIFI_OFF);
    delay(1000);
    WiFi.mode(WIFI_STA);
    WiFi.begin();
    retries = 0;
    while (WiFi.status() != WL_CONNECTED && retries++ < 20) {
      delay(500);
      Serial.print(".");
    }
    if (WiFi.status() == WL_CONNECTED) {
      Serial.printf("\n[WIFI] Zweiter Versuch -> OK, IP=%s\n", WiFi.localIP().toString().c_str());
    } else {
      Serial.println("\n[WIFI] Verbindung fehlgeschlagen!");
    }
  }
}

bool isResetButtonPressed() {
  const unsigned long debounceTime = 2000;
  unsigned long pressedTime = 0;
  if (digitalRead(RESET_BUTTON_PIN) == LOW) {
    Serial.println("[INFO] Reset-Taster erkannt...");
    pressedTime = millis();
    while (digitalRead(RESET_BUTTON_PIN) == LOW) {
      delay(100);
      if (millis() - pressedTime > debounceTime) {
        Serial.println("[INFO] Reset-Taster >2s -> WLAN-Daten loeschen");
        return true;
      }
    }
  }
  return false;
}

// --------------------------------------------------------------
// VL53L0X
// --------------------------------------------------------------
void calibrateVL53L0X() {
  Serial.println("[CAL] Starte VL53L0X-Kalibrierung...");
  if (!lox.begin()) {
    Serial.println("[CAL] VL53L0X init fehlgeschlagen!");
    return;
  }
  unsigned long start = millis();
  unsigned long dur = 3000;
  int currentMin = 9999;
  int currentMax = 0;

  while (millis() - start < dur) {
    VL53L0X_RangingMeasurementData_t m;
    lox.rangingTest(&m, false);
    if (m.RangeStatus != 4) {
      int d = m.RangeMilliMeter;
      if (d < currentMin) currentMin = d;
      if (d > currentMax) currentMax = d;
      Serial.printf("[CAL] Dist=%d\n", d);
    } else {
      Serial.println("[CAL] Ungültig...");
    }
    delay(50);
  }
  if (currentMin < 9999 && currentMax > 0) {
    minDistance = currentMin - 15;
    maxDistance = currentMax + 15;
    preferences.putInt("minDistance", minDistance);
    preferences.putInt("maxDistance", maxDistance);
    Serial.printf("[CAL DONE] min=%d, max=%d\n", minDistance, maxDistance);
  } else {
    Serial.println("[CAL] Keine sinnvollen Werte.");
  }
}

// --------------------------------------------------------------
// Logs
// --------------------------------------------------------------
void addLogEntry(const String &entry) {
  // Zeitstempel
  unsigned long ms = millis();
  String newLine = "[T=" + String(ms) + "] " + entry;
  
  if (!logsBuffer.isEmpty()) logsBuffer += "\\n";
  logsBuffer += newLine;
  
  Serial.println("[LOG] " + newLine);
}

/**
 * Korrigierte Funktion: 'logs' als JSON-Array statt als String senden.
 */
void sendLogs() {
  if (logsBuffer.isEmpty()) {
    Serial.println("[LOG] Keine Logs zu senden.");
    return;
  }
  
  String mac = preferences.getString("mac_address", "Unbekannt");
  
  // JSON-Dokument anlegen (Größe ggf. anpassen)
  StaticJsonDocument<1024> doc;
  doc["mac_address"] = mac;
  
  // Array "logs" erstellen
  JsonArray logs = doc.createNestedArray("logs");
  
  // logsBuffer enthält Zeilen getrennt durch "\\n"
  int startIndex = 0;
  while (startIndex < logsBuffer.length()) {
    int endIndex = logsBuffer.indexOf("\\n", startIndex);
    if (endIndex == -1) {
      String line = logsBuffer.substring(startIndex);
      logs.add(line);
      break;
    } else {
      String line = logsBuffer.substring(startIndex, endIndex);
      logs.add(line);
      startIndex = endIndex + 2; // +2 wegen "\\n"
    }
  }
  
  String payload;
  serializeJson(doc, payload);
  
  Serial.println("[LOG] Sende Logs -> /logs");
  Serial.println("[HTTP] Payload: " + payload);
  
  sendToServer(logsServerUrl, payload);
  
  logsBuffer = "";
}

// --------------------------------------------------------------
// 10-Sekunden-Messung + Senden
// --------------------------------------------------------------
std::vector<int> collectMeasurementsForTenSeconds() {
  std::vector<int> distances;
  Serial.println("[MEASURE] Starte 10s-Messung...");
  
  if (!lox.begin()) {
    Serial.println("[MEASURE] VL53L0X init fehlgeschlagen!");
    addLogEntry("VL53 init fail");
    return distances;
  }
  
  lox.setMeasurementTimingBudgetMicroSeconds(20000);
  unsigned long start = millis();
  while (millis() - start < 10000) {
    VL53L0X_RangingMeasurementData_t m;
    lox.rangingTest(&m, false);
    if (m.RangeStatus != 4) {
      int d = m.RangeMilliMeter;
      distances.push_back(d);
      Serial.printf("[MEASURE] Dist=%d\n", d);
    } else {
      Serial.println("[MEASURE] Ungültig");
    }
    delay(20);
  }
  return distances;
}

void sendMeasurements(const std::vector<int> &measurements) {
  if (measurements.empty()) return;
  
  // JSON-Array aufbauen
  String arr = "[";
  for (size_t i = 0; i < measurements.size(); i++) {
    arr += String(measurements[i]);
    if (i < measurements.size() - 1) arr += ",";
  }
  arr += "]";
  
  String mac = preferences.getString("mac_address", "Unbekannt");
  String payload = "{\"mac_address\":\"" + mac + "\",\"measurements\":" + arr + "}";
  Serial.println("[MEASURE] POST -> /measurements:\n" + payload);
  sendToServer(measurementsServerUrl, payload);
  
  addLogEntry("Measurements sent. Count=" + String(measurements.size()));
}

void analyzeAndSendEvents(const std::vector<int> &distances) {
  if (distances.empty()) return;
  int minVal = *std::min_element(distances.begin(), distances.end());
  int maxVal = *std::max_element(distances.begin(), distances.end());
  Serial.printf("[ANALYSE] min=%d, max=%d\n", minVal, maxVal);
  
  bool briefErkannt    = (minVal < minDistance);
  bool kastenGeoeffnet = (maxVal > maxDistance);
  
  if (kastenGeoeffnet) {
    Serial.printf("[EVENT] Tür geöffnet (max=%d)\n", maxVal);
    sendDoorEvent(maxVal);
  } else if (briefErkannt) {
    Serial.printf("[EVENT] Brief erkannt (min=%d)\n", minVal);
    sendLetterEvent(minVal);
  } else {
    Serial.println("[ANALYSE] Kein Event erkannt.");
    addLogEntry("No event recognized in 10s measure.");
  }
}

// --------------------------------------------------------------
// Events + KeepAlive
// --------------------------------------------------------------
void sendDeviceInfo() {
  Serial.println("[DEV] sendDeviceInfo()");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  String jsonPayload = "{\"mac_address\":\"" + mac +
                       "\", \"firmware_version\":\"" + CURRENT_FIRMWARE_VERSION + "\"}";
  sendToServer(registrationServerUrl, jsonPayload);
  addLogEntry("DeviceInfo sent.");
}

void sendCalibrationData() {
  Serial.println("[CAL] sendCalibrationData()");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  String payload = "{\"mac_address\":\"" + mac +
                   "\", \"min_distance\":" + String(minDistance) +
                   ", \"max_distance\":" + String(maxDistance) + "}";
  sendToServer(calibrationServerUrl, payload);
  addLogEntry("Calibration data sent.");
}

void sendLetterEvent(int distance) {
  Serial.println("[EVENT] sendLetterEvent()");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  String payload = "{\"mac_address\":\"" + mac +
                   "\", \"event\":\"letter_detected\", \"distance\":" + String(distance) + "}";
  sendToServer(letterServerUrl, payload);
  addLogEntry("LetterEvent dist=" + String(distance));
}

void sendDoorEvent(int distance) {
  Serial.println("[EVENT] sendDoorEvent()");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  String payload = "{\"mac_address\":\"" + mac +
                   "\", \"event\":\"door_opened\", \"distance\":" + String(distance) + "}";
  sendToServer(doorServerUrl, payload);
  addLogEntry("DoorEvent dist=" + String(distance));
}

void sendKeepAlive() {
  Serial.println("[ALIVE] sendKeepAlive()");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  String payload = "{\"mac_address\":\"" + mac + "\"}";
  sendToServer(keepaliveServerUrl, payload);
  addLogEntry("KeepAlive sent.");
}

// --------------------------------------------------------------
// sendToServer: Post an HTTP-Endpoint
// --------------------------------------------------------------
void sendToServer(const char* serverUrl, String jsonPayload) {
  connectToWiFi();
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");
    
    int code = http.POST(jsonPayload);
    if (code > 0) {
      String resp = http.getString();
      Serial.printf("[HTTP] Code=%d\n", code);
      Serial.printf("[HTTP] Body=%s\n", resp.c_str());
    } else {
      Serial.printf("[HTTP] Fehler: %s\n", http.errorToString(code).c_str());
    }
    http.end();
  } else {
    Serial.println("[HTTP] Kein WLAN -> kann nicht senden.");
  }
}

// --------------------------------------------------------------
// OTA-spezifisch
// --------------------------------------------------------------
void sendPing() {
  if (WiFi.status() != WL_CONNECTED) return;
  HTTPClient http;
  String url = String(ota_host) + "/ping";
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  
  String body = "{\"mac\": \"" + WiFi.macAddress() + "\", \"version\": \"" + CURRENT_FIRMWARE_VERSION + "\"}";
  int code = http.POST(body);
  if (code > 0) {
    Serial.printf("[OTA] Ping -> HTTP %d\n", code);
  } else {
    Serial.printf("[OTA] Ping Fehler: %d\n", code);
  }
  http.end();
}

void checkDeviceFirmware() {
  if (WiFi.status() != WL_CONNECTED) return;
  HTTPClient http;
  String url = String(ota_host) + "/device_firmware.json?mac=" + WiFi.macAddress();
  http.begin(url);
  int code = http.GET();
  if (code == 200) {
    String payload = http.getString();
    StaticJsonDocument<512> doc;
    DeserializationError err = deserializeJson(doc, payload);
    if (!err) {
      const char* assignedVersion = doc["version"];
      const char* firmwareUrl     = doc["url"];
      Serial.printf("[OTA] Local=%s, Assigned=%s\n", CURRENT_FIRMWARE_VERSION, assignedVersion);
      if (String(assignedVersion) != CURRENT_FIRMWARE_VERSION && String(assignedVersion) != "") {
        performOTA(firmwareUrl);
      } else {
        Serial.println("[OTA] Keine neuere Version.");
      }
    } else {
      Serial.println("[OTA] JSON parse error");
    }
  } else {
    Serial.printf("[OTA] device_firmware.json -> HTTP %d\n", code);
  }
  http.end();
}

void performOTA(String firmwareUrl) {
  if (WiFi.status() != WL_CONNECTED) return;
  HTTPClient http;
  http.begin(firmwareUrl);
  int code = http.GET();
  if (code == 200) {
    int cLen = http.getSize();
    if (cLen <= 0) {
      Serial.println("[OTA] Ungültige Content-Length");
      return;
    }
    if (!Update.begin(cLen)) {
      Serial.println("[OTA] Nicht genug Speicher");
      return;
    }
    WiFiClient &stream = http.getStream();
    int written = 0;
    int lastPct = -1;
    uint8_t buff[128];
    
    while (http.connected() && written < cLen) {
      int size = stream.available();
      if (size) {
        int len = stream.readBytes(buff, (size > sizeof(buff) ? sizeof(buff) : size));
        Update.write(buff, len);
        written += len;
        int pct = (written * 100) / cLen;
        if (pct != lastPct) {
          Serial.printf("[OTA] %d%%\n", pct);
          lastPct = pct;
        }
      }
      delay(1);
    }
    
    if (Update.end()) {
      if (Update.isFinished()) {
        Serial.println("[OTA] Update fertig -> Neustart");
        delay(500);
        ESP.restart();
      } else {
        Serial.println("[OTA] Update nicht korrekt beendet");
      }
    } else {
      Serial.printf("[OTA] Fehler: %s\n", Update.errorString());
    }
  } else {
    Serial.printf("[OTA] Laden fehlgeschlagen (HTTP=%d)\n", code);
  }
  http.end();
}

// --------------------------------------------------------------
// Deep Sleep
// --------------------------------------------------------------
void configureDeepSleep() {
  Serial.println("[DEEPSLEEP] configureDeepSleep()");
  // ext0: PIR-Sensor
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_27, 1);
  // Timer
  esp_sleep_enable_timer_wakeup(keepAliveInterval * 1000ULL);
  
  Serial.println("[DEEPSLEEP] 5s bis Sleep");
  delay(5000);
  Serial.println("[DEEPSLEEP] Going Sleep!");
  esp_deep_sleep_start();
}
