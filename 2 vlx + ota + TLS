#include <WiFi.h>
#include <WiFiClientSecure.h> // Added for HTTPS
#include <HTTPClient.h>
#include <Wire.h>
#include <VL53L0X.h>
#include <Preferences.h>
#include <WiFiManager.h>
#include <vector>
#include <numeric>
#include <Update.h>
#include <ArduinoJson.h>

// ---------------------- Secure Client & Certificate ---------------------- //
static const char *LE_ROOT_CA PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIFYDCCBEigAwIBAgIQQAF3ITfU6UK47naqPGQKtzANBgkqhkiG9w0BAQsFADA/
MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT
DkRTVCBSb290IENBIFgzMB4XDTIxMDEyMDE5MTQwM1oXDTI0MDkzMDE4MTQwM1ow
TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwggIiMA0GCSqGSIb3DQEB
AQUAA4ICDwAwggIKAoICAQCt6CRz9BQ385ueK1coHIe+3LffOJCMbjzmV6B493XC
ov71am72AE8o295ohmxEk7axY/0UEmu/H9LqMZshftEzPLpI9d1537O4/xLxIZpL
wYqGcWlKZmZsj348cL+tKSIG8+TA5oCu4kuPt5l+lAOf00eXfJlII1PoOK5PCm+D
LtFJV4yAdLbaL9A4jXsDcCEbdfIwPPqPrt3aY6vrFk/CjhFLfs8L6P+1dy70sntK
4EwSJQxwjQMpoOFTJOwT2e4ZvxCzSow/iaNhUd6shweU9GNx7C7ib1uYgeGJXDR5
bHbvO5BieebbpJovJsXQEOEO3tkQjhb7t/eo98flAgeYjzYIlefiN5YNNnWe+w5y
sR2bvAP5SQXYgd0FtCrWQemsAXaVCg/Y39W9Eh81LygXbNKYwagJZHduRze6zqxZ
Xmidf3LWicUGQSk+WT7dJvUkyRGnWqNMQB9GoZm1pzpRboY7nn1ypxIFeFntPlF4
FQsDj43QLwWyPntKHEtzBRL8xurgUBN8Q5N0s8p0544fAQjQMNRbcTa0B7rBMDBc
SLeCO5imfWCKoqMpgsy6vYMEG6KDA0Gh1gXxG8K28Kh8hjtGqEgqiNx2mna/H2ql
PRmP6zjzZN7IKw0KKP/32+IVQtQi0Cdd4Xn+GOdwiK1O5tmLOsbdJ1Fu/7xk9TND
TwIDAQABo4IBRjCCAUIwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYw
SwYIKwYBBQUHAQEEPzA9MDsGCCsGAQUFBzAChi9odHRwOi8vYXBwcy5pZGVudHJ1
c3QuY29tL3Jvb3RzL2RzdHJvb3RjYXgzLnA3YzAfBgNVHSMEGDAWgBTEp7Gkeyxx
+tvhS5B1/8QVYIWJEDBUBgNVHSAETTBLMAgGBmeBDAECATA/BgsrBgEEAYLfEwEB
ATAwMC4GCCsGAQUFBwIBFiJodHRwOi8vY3BzLnJvb3QteDEubGV0c2VuY3J5cHQu
b3JnMDwGA1UdHwQ1MDMwMaAvoC2GK2h0dHA6Ly9jcmwuaWRlbnRydXN0LmNvbS9E
U1RST09UQ0FYM0NSTC5jcmwwHQYDVR0OBBYEFHm0WeZ7tuXkAXOACIjIGlj26Ztu
MA0GCSqGSIb3DQEBCwUAA4IBAQAKcwBslm7/DlLQrt2M51oGrS+o44+/yQoDFVDC
5WxCu2+b9LRPwkSICHXM6webFGJueN7sJ7o5XPWioW5WlHAQU7G75K/QosMrAdSW
9MUgNTP52GE24HGNtLi1qoJFlcDyqSMo59ahy2cI2qBDLKobkx/J3vWraV0T9VuG
WCLKTVXkcGdtwlfFRjlBz4pYg1htmf5X6DYO8A4jqv2Il9DjXA6USbW1FzXSLr9O
he8Y4IWS6wY7bCkjCWDcRQJMEhg76fsO3txE+FiYruq9RUWhiF1myv4Q6W+CyBFC
Dfvp7OOGAN6dEOM4+qR9sdjoSYKEBpsr6GtPAQw4dy753ec5
-----END CERTIFICATE-----
)EOF";

WiFiClientSecure secureClient; // Secure client object

void setupSecureClient() {
  secureClient.setCACert(LE_ROOT_CA);
  // secureClient.setInsecure(); // Optional: Disable validation (NOT RECOMMENDED)
}

// ---------------------- Konfiguration ---------------------- //
const char* serverBaseUrl = "https://eshghabadi.com"; // Use HTTPS

String registrationServerUrl = String(serverBaseUrl) + "/device";
String calibrationServerUrl  = String(serverBaseUrl) + "/calibration";
String letterServerUrl       = String(serverBaseUrl) + "/letter";
String doorServerUrl         = String(serverBaseUrl) + "/door";
String keepaliveServerUrl    = String(serverBaseUrl) + "/keepalive";
String logsServerUrl         = String(serverBaseUrl) + "/logs";
String measurementsServerUrl = String(serverBaseUrl) + "/measurements"; // Target for combined measurements

String ota_host              = String(serverBaseUrl);
#define CURRENT_FIRMWARE_VERSION    "1.0.5.9" // Increment version after change

unsigned long lastPingTime        = 0;
unsigned long lastKeepAlive       = 0;
const unsigned long keepAliveInterval = 15 * 60 * 1000; // 15 Minuten

#define PIR_PIN            27
#define LED_PIN            2
#define RESET_BUTTON_PIN   0
#define XSHUT_1            25
#define XSHUT_2            19

// ---------------------- Sensor-Objekte ---------------------- //
TwoWire I2C_VLX1 = TwoWire(0);
TwoWire I2C_VLX2 = TwoWire(1);
VL53L0X sensor1;
VL53L0X sensor2;

// ---------------------- Kalibrierungswerte ---------------------- //
int minDistance1 = 0, maxDistance1 = 0;
int minDistance2 = 0, maxDistance2 = 0;

// ---------------------- Logging ---------------------- //
String logsBuffer;

// ---------------------- Sensor & Speicher ---------------------- //
Preferences preferences;

// ---------------------- Vorwärtsdeklarationen ---------------------- //
void connectToWiFi();
bool isResetButtonPressed();
void calibrateSensor(VL53L0X &sensor, int &calibMin, int &calibMax, const String &sensorLabel);
void analyzeAndSendEventsSensor(const std::vector<int> &distances, int calibMin, int calibMax, const String &sensorLabel);
void sendCombinedMeasurements(const std::vector<int> &measurements1, const std::vector<int> &measurements2); // NEU
void addLogEntry(const String &entry);
void sendToServer(const String& serverUrl, const String& jsonPayload);
void sendPing();
void checkDeviceFirmware();
void performOTA(String firmwareUrl);
void sendDeviceInfo();
void sendCalibrationData();
void sendLetterEvent(int distance, const String &sensorLabel);
void sendDoorEvent(int distance, const String &sensorLabel);
void sendKeepAlive();
void sendLogs();
void configureDeepSleep();
void initSensors();

// ---------------------- Sensorinitialisierung ---------------------- //
void initSensors() {
  Serial.println("[SENSORS] Initialisiere beide VL53L0X-Sensoren...");
  pinMode(XSHUT_1, OUTPUT);
  pinMode(XSHUT_2, OUTPUT);

  digitalWrite(XSHUT_1, LOW);
  digitalWrite(XSHUT_2, LOW);
  delay(50);

  // Sensor 1
  digitalWrite(XSHUT_1, HIGH);
  delay(50);
  I2C_VLX1.begin(21, 22);
  sensor1.setBus(&I2C_VLX1);
  if (!sensor1.init(true)) {
    Serial.println("❌ Sensor 1 Init fehlgeschlagen!");
    addLogEntry("Sensor 1 init failed"); while (1);
  }
  sensor1.setAddress(0x30);
  sensor1.setMeasurementTimingBudget(20000);
  sensor1.startContinuous();
  Serial.println("✅ Sensor 1 aktiv auf Adresse 0x30");

  // Sensor 2
  digitalWrite(XSHUT_2, HIGH);
  delay(50);
  I2C_VLX2.begin(16, 17);
  sensor2.setBus(&I2C_VLX2);
  if (!sensor2.init(true)) {
    Serial.println("❌ Sensor 2 Init fehlgeschlagen!");
    addLogEntry("Sensor 2 init failed"); while (1);
  }
  sensor2.setAddress(0x31);
  sensor2.setMeasurementTimingBudget(20000);
  sensor2.startContinuous();
  Serial.println("✅ Sensor 2 aktiv auf Adresse 0x31");

  Serial.println("[SENSORS] Sensorinitialisierung abgeschlossen.");
}

// ---------------------- setup() ---------------------- //
void setup() {
  pinMode(PIR_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);

  Serial.begin(115200);
  delay(200);
  Serial.println("\n\n[BOOT/WAKEUP] Starte...");

  preferences.begin("briefkasten", false);
  WiFiManager wifiManager;

  if (isResetButtonPressed()) {
    Serial.println("[INFO] Reset-Taster gedrückt -> Lösche gespeicherte WLAN-Daten.");
    wifiManager.resetSettings();
    preferences.clear();
    Serial.println("[INFO] Alle Preferences gelöscht. Neustart...");
    delay(1000);
    ESP.restart();
  }

  initSensors(); // Initialize sensors early

  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();

  if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
    // PIR-Aufwachen: Sofort Messung
    Serial.println("[WAKEUP] PIR-Sensor (EXT0) geweckt");
    digitalWrite(LED_PIN, HIGH);

    Serial.println("[MEASURE] Starte 10s simultane Messung beider Sensoren...");
    std::vector<int> distances1;
    std::vector<int> distances2;
    unsigned long start = millis();
    const unsigned long measureDuration = 10000; // 10 seconds
    while (millis() - start < measureDuration) {
      int d1 = sensor1.readRangeContinuousMillimeters();
      int d2 = sensor2.readRangeContinuousMillimeters();
      if (!sensor1.timeoutOccurred() && d1 > 0 && d1 < 8190) distances1.push_back(d1);
      if (!sensor2.timeoutOccurred() && d2 > 0 && d2 < 8190) distances2.push_back(d2);
      delay(30);
    }
    Serial.println("[MEASURE] Simultane Messung beendet.");

    Serial.println("[WIFI] Verbinde WLAN...");
    connectToWiFi();

    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("[WIFI] Verbunden.");
      setupSecureClient();

      minDistance1 = preferences.getInt("minDistance1", 0);
      maxDistance1 = preferences.getInt("maxDistance1", 0);
      minDistance2 = preferences.getInt("minDistance2", 0);
      maxDistance2 = preferences.getInt("maxDistance2", 0);

      String macAddress = preferences.getString("mac_address", "Nicht gesetzt");
      Serial.printf("[INFO] MAC=%s\n", macAddress.c_str());

      if (minDistance1 == 0 || maxDistance1 == 0 || minDistance2 == 0 || maxDistance2 == 0) {
        Serial.println("[WARNUNG] Keine (gültigen) Kalibrierungsdaten gefunden.");
        addLogEntry("Missing or invalid calibration on PIR wakeup.");
      }

      // === NEU: Sende kombinierte Messdaten ===
      if (!distances1.empty() || !distances2.empty()) {
          sendCombinedMeasurements(distances1, distances2);
      } else {
          addLogEntry("Keine Messwerte von beiden Sensoren beim PIR-Wakeup.");
      }
      // ========================================

      // Analysiere Events nur wenn kalibriert
      if (minDistance1 != 0 && maxDistance1 != 0)
        analyzeAndSendEventsSensor(distances1, minDistance1, maxDistance1, "sensor1");
      else
        addLogEntry("Überspringe Ereignisanalyse sensor1 wegen fehlender Kalibrierung.");

      if (minDistance2 != 0 && maxDistance2 != 0)
        analyzeAndSendEventsSensor(distances2, minDistance2, maxDistance2, "sensor2");
      else
        addLogEntry("Überspringe Ereignisanalyse sensor2 wegen fehlender Kalibrierung.");

      sendLogs();
    } else {
      Serial.println("[ERROR] Kein WLAN - Messdaten können nicht gesendet werden.");
      addLogEntry("No WiFi after PIR measurement. Data lost.");
    }

    digitalWrite(LED_PIN, LOW);
    Serial.println("[DEEPSLEEP] Gehe in Deep Sleep (PIR)...");
    configureDeepSleep();

  } else if (wakeup_reason == ESP_SLEEP_WAKEUP_TIMER) {
    // Timer-Aufwachen
    Serial.println("[WAKEUP] Timer (KeepAlive/OTA Check)");
    connectToWiFi();
    if (WiFi.status() == WL_CONNECTED) {
      setupSecureClient();
      sendPing();
      checkDeviceFirmware();
      sendKeepAlive();
      sendLogs();
    } else {
      addLogEntry("No WiFi on Timer Wakeup.");
    }
    configureDeepSleep();

  } else {
    // Normaler Start
    Serial.printf("[BOOT] Normaler Start (Wakeup-Grund: %d)\n", wakeup_reason);
    digitalWrite(LED_PIN, HIGH);

    wifiManager.setConfigPortalTimeout(180);
    if (!wifiManager.autoConnect("BriefkastenAP")) {
      addLogEntry("WiFi AutoConnect Failed or Timed Out. Restarting.");
      Serial.println("[WIFI] Konfigurationsportal fehlgeschlagen/Timeout. Neustart...");
      delay(5000);
      ESP.restart();
    }

    Serial.printf("[WIFI] Verbunden! IP=%s\n", WiFi.localIP().toString().c_str());
    setupSecureClient();

    String mac = WiFi.macAddress();
    Serial.printf("[INFO] MAC Addresse: %s\n", mac.c_str());
    String storedMac = preferences.getString("mac_address", "");
    if (storedMac != mac) {
        preferences.putString("mac_address", mac);
        addLogEntry(storedMac == "" ? "MAC address stored." : "MAC address updated.");
    }

    sendDeviceInfo();

    Serial.println("[CAL] Warte 3 Minuten vor der Kalibrierung...");
    delay(5); // 3 Minuten

    Serial.println("[CAL] Starte Kalibrierung der Sensoren...");
    calibrateSensor(sensor1, minDistance1, maxDistance1, "sensor1");
    calibrateSensor(sensor2, minDistance2, maxDistance2, "sensor2");
    sendCalibrationData();

    sendPing();
    checkDeviceFirmware();
    sendLogs();
    digitalWrite(LED_PIN, LOW);
    configureDeepSleep();
  }
}

// ---------------------- loop() ---------------------- //
void loop() {
  delay(10000);
  Serial.println("[LOOP] Unerwarteter Loop-Durchlauf. Gehe schlafen...");
  addLogEntry("Unexpected loop execution. Entering deep sleep.");
  configureDeepSleep();
}

// ---------------------- Funktionen ---------------------- //

void connectToWiFi() {
  // (wie gehabt)
  if (WiFi.status() == WL_CONNECTED) return;
  Serial.println("[WIFI] Versuche Verbindung mit gespeicherten Daten...");
  WiFi.begin();
  int retries = 0;
  const int maxRetries = 20;
  while (WiFi.status() != WL_CONNECTED && retries++ < maxRetries) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("[WIFI] Verbunden! IP=%s\n", WiFi.localIP().toString().c_str());
  } else {
    Serial.println("[WIFI] Verbindung fehlgeschlagen nach Retries.");
  }
}

bool isResetButtonPressed() {
   // (wie gehabt)
  if (digitalRead(RESET_BUTTON_PIN) == LOW) {
    Serial.println("[INFO] Reset-Taster (GPIO0) beim Start LOW erkannt.");
    unsigned long pressedTime = millis();
    while (digitalRead(RESET_BUTTON_PIN) == LOW) {
      delay(50);
      if (millis() - pressedTime > 2000) {
        Serial.println("[INFO] Reset-Taster > 2s gehalten -> Aktion auslösen.");
        return true;
      }
    }
    Serial.println("[INFO] Reset-Taster < 2s gehalten -> Keine Aktion.");
  }
  return false;
}

void calibrateSensor(VL53L0X &sensor, int &calibMin, int &calibMax, const String &sensorLabel) {
   // (wie gehabt)
  Serial.println("[CAL] Starte Kalibrierung für " + sensorLabel + "...");
  unsigned long calibrationStartTime = millis();
  const unsigned long calibrationDuration = 3000;
  int currentMin = 8190;
  int currentMax = 0;
  int measurementCount = 0;
  int validMeasurements = 0;
  Serial.println("[CAL] Messe 3 Sekunden lang (gültig, wenn Messwert nicht fehlerhaft)...");
  while (millis() - calibrationStartTime < calibrationDuration) {
    measurementCount++;
    int distance = sensor.readRangeContinuousMillimeters();
    if (!sensor.timeoutOccurred() && distance > 0 && distance < 8190) {
      if (distance < currentMin) currentMin = distance;
      if (distance > currentMax) currentMax = distance;
      validMeasurements++;
    }
    delay(50);
  }
  Serial.printf("[CAL] %s Kalibrierung beendet. Versuche=%d, gültige Messungen=%d\n", sensorLabel.c_str(), measurementCount, validMeasurements);
  if (validMeasurements > 5 && currentMin < 8190) {
    const int calibrationMargin = 15;
    calibMin = currentMin - calibrationMargin;
    if (calibMin < 5) calibMin = 5;
    calibMax = currentMax + calibrationMargin;
    preferences.putInt(("minDistance" + sensorLabel.substring(6)).c_str(), calibMin);
    preferences.putInt(("maxDistance" + sensorLabel.substring(6)).c_str(), calibMax);
    Serial.printf("[CAL] %s erfolgreich: min=%d mm, max=%d mm (gespeichert)\n", sensorLabel.c_str(), calibMin, calibMax);
    addLogEntry("Calibration done for " + sensorLabel + ". Min=" + String(calibMin) +
                ", Max=" + String(calibMax) + " (ValidCnt=" + String(validMeasurements) + ")");
  } else {
    Serial.println("[CAL][ERROR] " + sensorLabel + ": Nicht genügend gültige Messwerte für Kalibrierung.");
    addLogEntry("Calibration failed for " + sensorLabel + " (ValidCnt=" + String(validMeasurements) + ")");
    calibMin = 0;
    calibMax = 0;
    preferences.remove(("minDistance" + sensorLabel.substring(6)).c_str());
    preferences.remove(("maxDistance" + sensorLabel.substring(6)).c_str());
  }
}

void analyzeAndSendEventsSensor(const std::vector<int> &distances, int calibMin, int calibMax, const String &sensorLabel) {
  // (wie gehabt)
  if (distances.empty()) {
    addLogEntry("Keine Messwerte zur Analyse für " + sensorLabel + ".");
    return;
  }
  int minVal = 8190;
  int maxVal = 0;
  for (int d : distances) {
    if (d < minVal) minVal = d;
    if (d > maxVal) maxVal = d;
  }
  Serial.printf("[ANALYSE] %s: gemessen: Min=%d mm, Max=%d mm | Kalibrierung: Min=%d, Max=%d\n",
                sensorLabel.c_str(), minVal, maxVal, calibMin, calibMax);
  const int doorThresholdMargin = 10;
  const int letterThresholdMargin = 10;
  bool doorOpened = (maxVal > (calibMax + doorThresholdMargin));
  bool letterDetected = (minVal < (calibMin - letterThresholdMargin));
  if (doorOpened) {
    Serial.printf("[EVENT] %s: Tür geöffnet erkannt (Messwert %d > Kalibrierung %d + Margin)\n",
                  sensorLabel.c_str(), maxVal, calibMax);
    sendDoorEvent(maxVal, sensorLabel);
  } else if (letterDetected) {
    Serial.printf("[EVENT] %s: Brief erkannt (Messwert %d < Kalibrierung %d - Margin)\n",
                  sensorLabel.c_str(), minVal, calibMin);
    sendLetterEvent(minVal, sensorLabel);
  } else {
    addLogEntry("Kein spezifisches Event bei " + sensorLabel + " erkannt. Measured Min/Max: " + String(minVal) + "/" + String(maxVal));
  }
}

// === NEUE Funktion zum Senden kombinierter Messdaten ===
void sendCombinedMeasurements(const std::vector<int> &measurements1, const std::vector<int> &measurements2) {
    if (measurements1.empty() && measurements2.empty()) {
        addLogEntry("Keine Messwerte von beiden Sensoren zum Senden.");
        return;
    }
     if (WiFi.status() != WL_CONNECTED) {
        addLogEntry("Kann kombinierte Messwerte nicht senden, kein WLAN.");
        return;
    }

    String mac = preferences.getString("mac_address", "Unbekannt");
    if (mac == "Unbekannt") {
        addLogEntry("Cannot send combined measurements, MAC address unknown.");
        return;
    }

    // JSON Dokument erstellen - Größe anpassen, falls viele Messwerte erwartet werden
    // Ca. Größe: Basis ~100 + MAC 17 + "data{}" ~10 + "sensor1":[] ~15 + "sensor2":[] ~15 + (N1 * 4) + (N2 * 4)
    // Bei 300 Werten pro Sensor: 100 + 17 + 10 + 15 + 15 + (300 * 4) + (300*4) = ~2757 -> 8192 ist sicher.
    DynamicJsonDocument doc(8192); // Größe großzügig wählen

    doc["mac_address"] = mac;
    JsonObject dataObj = doc.createNestedObject("data");

    // Füge Messwerte für Sensor 1 hinzu, falls vorhanden
    if (!measurements1.empty()) {
        JsonArray measureArray1 = dataObj.createNestedArray("sensor1");
        for (int measurement : measurements1) {
            measureArray1.add(measurement);
        }
    } else {
         dataObj["sensor1"] = JsonArray(); // Leeres Array senden, wenn keine Daten
    }


    // Füge Messwerte für Sensor 2 hinzu, falls vorhanden
    if (!measurements2.empty()) {
        JsonArray measureArray2 = dataObj.createNestedArray("sensor2");
        for (int measurement : measurements2) {
            measureArray2.add(measurement);
        }
    } else {
        dataObj["sensor2"] = JsonArray(); // Leeres Array senden, wenn keine Daten
    }

    String payload;
    serializeJson(doc, payload);

    // Optional: JSON Payload auf Serial Monitor ausgeben zum Debuggen
    // Serial.println("[JSON PAYLOAD] /measurements:");
    // Serial.println(payload);

    Serial.println("[MEASURE] Sende kombinierte Messwerte an Server -> /measurements");
    sendToServer(measurementsServerUrl, payload);
    addLogEntry("Combined measurements sent. Sensor1 Count=" + String(measurements1.size()) +
                ", Sensor2 Count=" + String(measurements2.size()));
}


void sendToServer(const String& serverUrl, const String& jsonPayload) {
   // (wie gehabt)
  if (WiFi.status() != WL_CONNECTED) {
    Serial.printf("[HTTPS] Kein WLAN -> Kann nicht an %s senden.\n", serverUrl.c_str());
    addLogEntry("HTTPS Send failed (No WiFi) to " + serverUrl);
    return;
  }
  HTTPClient http;
  Serial.printf("[HTTPS] Verbinde mit: %s\n", serverUrl.c_str());
  if (!http.begin(secureClient, serverUrl)) {
    Serial.printf("[HTTPS][ERROR] http.begin() fehlgeschlagen für URL: %s\n", serverUrl.c_str());
    addLogEntry("HTTPS begin failed for " + serverUrl);
    return;
  }
  http.addHeader("Content-Type", "application/json");
  http.setConnectTimeout(5000);
  http.setTimeout(10000);
  int httpCode = http.POST(jsonPayload);
  if (httpCode > 0) {
    if (httpCode >= 200 && httpCode < 300) {
         Serial.printf("[HTTPS] POST an %s erfolgreich, Code: %d\n", serverUrl.c_str(), httpCode);
    } else {
      String response = http.getString();
      Serial.printf("[HTTPS][ERROR] URL: %s -> Code: %d, Resp: %s\n",
                    serverUrl.c_str(), httpCode, response.c_str());
      addLogEntry("HTTPS POST to " + serverUrl + " failed with code: " + String(httpCode));
    }
  } else {
    Serial.printf("[HTTPS][ERROR] Fehler beim Senden an %s: %s\n",
                  serverUrl.c_str(), http.errorToString(httpCode).c_str());
    addLogEntry("HTTPS POST to " + serverUrl + " failed: " + http.errorToString(httpCode));
  }
  http.end();
}

void sendPing() {
    // --- KORREKTUR: Größe für StaticJsonDocument angeben ---
    StaticJsonDocument<256> doc;
    // --- Rest der Funktion wie gehabt ---
     if (WiFi.status() != WL_CONNECTED) return;
     String mac = preferences.getString("mac_address", "Unbekannt");
     if (mac == "Unbekannt") return;
     HTTPClient http;
     String url = ota_host + "/ping";
     Serial.printf("[OTA PING] Sende Ping an: %s\n", url.c_str());
     if(!http.begin(secureClient, url)) { addLogEntry("OTA Ping https.begin() failed."); return; }
     http.addHeader("Content-Type", "application/json");
     http.setTimeout(8000);
     // StaticJsonDocument doc; // Korrigierte Zeile nach oben verschoben
     doc["mac"] = mac;
     doc["version"] = CURRENT_FIRMWARE_VERSION;
     String body;
     serializeJson(doc, body);
     int code = http.POST(body);
     if (code > 0) {
         if (code >= 200 && code < 300) {
             Serial.printf("[OTA PING] Ping erfolgreich, Code: %d\n", code);
         } else {
             Serial.printf("[OTA PING] Ping fehlgeschlagen, Server antwortet mit Code: %d\n", code);
             addLogEntry("OTA Ping failed with HTTP code: " + String(code));
         }
     } else {
         Serial.printf("[OTA PING] Ping Fehler: %s\n", http.errorToString(code).c_str());
         addLogEntry("OTA Ping failed: " + http.errorToString(code));
     }
     http.end();
}

void checkDeviceFirmware() {
   // (wie gehabt)
    if (WiFi.status() != WL_CONNECTED) return;
    String mac = preferences.getString("mac_address", "Unbekannt");
    if (mac == "Unbekannt") return;
    HTTPClient http;
    String url = ota_host + "/device_firmware.json?mac=" + mac;
    Serial.printf("[OTA CHECK] Prüfe Firmware auf: %s\n", url.c_str());
    if(!http.begin(secureClient, url)) { addLogEntry("OTA Check https.begin() failed."); return; }
    http.setTimeout(8000);
    int code = http.GET();
    if (code == HTTP_CODE_OK) {
        String payload = http.getString();
        Serial.println("[OTA CHECK] Server Antwort: " + payload);
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, payload);
        if (!err) {
            const char* assignedVersion = doc["version"];
            const char* firmwareUrl = doc["url"];
            if (assignedVersion && firmwareUrl) {
                Serial.printf("[OTA CHECK] Aktuell: %s, Server: %s\n", CURRENT_FIRMWARE_VERSION, assignedVersion);
                if (strlen(firmwareUrl) > 0 && String(assignedVersion) != CURRENT_FIRMWARE_VERSION) {
                    Serial.println("[OTA] Neuere Version verfügbar! Starte OTA Update...");
                    addLogEntry("New firmware version " + String(assignedVersion) + " available. Starting OTA from " + String(firmwareUrl));
                    performOTA(String(firmwareUrl));
                } else {
                   Serial.println("[OTA CHECK] Firmware ist aktuell.");
                }
            } else { addLogEntry("OTA check failed: 'version' or 'url' field missing."); Serial.println("[OTA CHECK][ERROR] Ungültige JSON-Antwort."); }
        } else { addLogEntry("OTA check failed: JSON parse error - " + String(err.c_str())); Serial.println("[OTA CHECK][ERROR] Fehler beim Parsen: " + String(err.c_str())); }
    } else if (code == HTTP_CODE_NOT_FOUND) { Serial.println("[OTA CHECK] Keine spezifische Firmware gefunden (404).");
    } else { addLogEntry("OTA check failed: HTTP " + String(code) + " " + http.errorToString(code)); Serial.printf("[OTA CHECK][ERROR] HTTP Fehler: %d %s\n", code, http.errorToString(code).c_str()); }
    http.end();
}

void performOTA(String firmwareUrl) {
    // (wie gehabt)
     if (WiFi.status() != WL_CONNECTED) { addLogEntry("OTA failed: No WiFi connection."); return; }
     if (!firmwareUrl.startsWith("https://")) { addLogEntry("OTA failed: Firmware URL is not HTTPS: " + firmwareUrl); return; }
     Serial.printf("[OTA] Starte Download von: %s\n", firmwareUrl.c_str());
     addLogEntry("Starting OTA download from " + firmwareUrl);
     HTTPClient http;
     if (!http.begin(secureClient, firmwareUrl)) { addLogEntry("OTA download https.begin() failed."); return; }
     http.setTimeout(60000);
     int code = http.GET();
     if (code == HTTP_CODE_OK) {
         int contentLength = http.getSize();
         if (contentLength <= 0) { addLogEntry("OTA failed: Invalid Content-Length."); Serial.println("[OTA][ERROR] Ungültige Inhaltslänge."); http.end(); return; }
         Serial.printf("[OTA] Firmware Größe: %d Bytes\n", contentLength);
         if (!Update.begin(contentLength)) { addLogEntry("OTA failed: Not enough space - " + String(Update.errorString())); Serial.println("[OTA][ERROR] Nicht genügend Speicherplatz: " + String(Update.errorString())); http.end(); return; }
         addLogEntry("OTA Update started. Size: " + String(contentLength));
         Serial.println("[OTA] Update gestartet, schreibe Flash...");
         WiFiClient& stream = http.getStream();
         size_t written = Update.writeStream(stream);
         if (written != contentLength) { addLogEntry("OTA failed: Write error. Expected=" + String(contentLength) + ", Written=" + String(written) + ", Error: " + String(Update.errorString())); Serial.printf("[OTA][ERROR] Fehler beim Schreiben. Erwartet=%d, Geschrieben=%d, Fehler: %s\n", contentLength, written, Update.errorString()); Update.abort(); http.end(); return; }
         if (!Update.end(true)) { addLogEntry("OTA failed: Error ending update - " + String(Update.errorString())); Serial.println("[OTA][ERROR] Fehler beim Beenden: " + String(Update.errorString())); }
         else { addLogEntry("OTA update finished successfully. Rebooting."); Serial.println("[OTA] Update erfolgreich!"); Serial.println("[OTA] Neustart..."); delay(3000); ESP.restart(); }
     } else { addLogEntry("OTA download failed: HTTP " + String(code) + " " + http.errorToString(code)); Serial.printf("[OTA][ERROR] Download fehlgeschlagen. Code: %d %s\n", code, http.errorToString(code).c_str()); }
     http.end();
}


void sendDeviceInfo() {
   // --- KORREKTUR: Größe für StaticJsonDocument angeben ---
  StaticJsonDocument<256> doc;
  // --- Rest der Funktion wie gehabt ---
  Serial.println("[DEV] Sende Geräteinfo...");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  if (mac == "Nicht gesetzt") { addLogEntry("Cannot send DeviceInfo, MAC address unknown."); return; }
  // StaticJsonDocument doc; // Korrigierte Zeile nach oben verschoben
  doc["mac_address"] = mac;
  doc["firmware_version"] = CURRENT_FIRMWARE_VERSION;
  String jsonPayload;
  serializeJson(doc, jsonPayload);
  sendToServer(registrationServerUrl, jsonPayload);
  addLogEntry("DeviceInfo sent.");
}

void sendCalibrationData() {
    // --- KORREKTUR: Größe für StaticJsonDocument angeben ---
  StaticJsonDocument<512> doc; // Etwas größer wegen verschachtelter Objekte
  // --- Rest der Funktion wie gehabt ---
  Serial.println("[CAL] Sende Kalibrierungsdaten...");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
   if (mac == "Nicht gesetzt") { addLogEntry("Cannot send CalibrationData, MAC address unknown."); return; }
  int savedMin1 = preferences.getInt("minDistance1", 0);
  int savedMax1 = preferences.getInt("maxDistance1", 0);
  int savedMin2 = preferences.getInt("minDistance2", 0);
  int savedMax2 = preferences.getInt("maxDistance2", 0);
  if (savedMin1 == 0 || savedMax1 == 0 || savedMin2 == 0 || savedMax2 == 0) { addLogEntry("Skipped sending invalid calibration data (from Prefs)."); return; }
  // StaticJsonDocument doc; // Korrigierte Zeile nach oben verschoben
  doc["mac_address"] = mac;
  JsonObject sensor1Data = doc.createNestedObject("sensor1");
  sensor1Data["min_distance"] = savedMin1;
  sensor1Data["max_distance"] = savedMax1;
  JsonObject sensor2Data = doc.createNestedObject("sensor2");
  sensor2Data["min_distance"] = savedMin2;
  sensor2Data["max_distance"] = savedMax2;
  String payload;
  serializeJson(doc, payload);
  sendToServer(calibrationServerUrl, payload);
  addLogEntry("Calibration data sent for both sensors.");
}

void sendLetterEvent(int distance, const String &sensorLabel) {
    // --- KORREKTUR: Größe für StaticJsonDocument angeben ---
  StaticJsonDocument<256> doc;
  // --- Rest der Funktion wie gehabt ---
  Serial.println("[EVENT] Sende 'Brief erkannt' Event für " + sensorLabel + "...");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  if (mac == "Nicht gesetzt") { addLogEntry("Cannot send LetterEvent, MAC address unknown."); return; }
  // StaticJsonDocument doc; // Korrigierte Zeile nach oben verschoben
  doc["mac_address"] = mac;
  doc["sensor"] = sensorLabel;
  doc["event"] = "letter_detected"; // Event-Typ als String
  doc["distance"] = distance;
  String payload;
  serializeJson(doc, payload);
  sendToServer(letterServerUrl, payload);
  addLogEntry("LetterEvent sent for " + sensorLabel + ". Dist=" + String(distance));
}

void sendDoorEvent(int distance, const String &sensorLabel) {
    // --- KORREKTUR: Größe für StaticJsonDocument angeben ---
  StaticJsonDocument<256> doc;
  // --- Rest der Funktion wie gehabt ---
  Serial.println("[EVENT] Sende 'Tür geöffnet' Event für " + sensorLabel + "...");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  if (mac == "Nicht gesetzt") { addLogEntry("Cannot send DoorEvent, MAC address unknown."); return; }
  // StaticJsonDocument doc; // Korrigierte Zeile nach oben verschoben
  doc["mac_address"] = mac;
  doc["sensor"] = sensorLabel;
  doc["event"] = "door_opened"; // Event-Typ als String
  doc["distance"] = distance;
  String payload;
  serializeJson(doc, payload);
  sendToServer(doorServerUrl, payload);
  addLogEntry("DoorEvent sent for " + sensorLabel + ". Dist=" + String(distance));
}

void sendKeepAlive() {
    // --- KORREKTUR: Größe für StaticJsonDocument angeben ---
  StaticJsonDocument<256> doc;// Klein, nur MAC (+ evtl. Batterie)
  // --- Rest der Funktion wie gehabt ---
  Serial.println("[ALIVE] Sende KeepAlive...");
  String mac = preferences.getString("mac_address", "Nicht gesetzt");
  if (mac == "Nicht gesetzt") { addLogEntry("Cannot send KeepAlive, MAC address unknown."); return; }
  // StaticJsonDocument doc; // Korrigierte Zeile nach oben verschoben
  doc["mac_address"] = mac;
  // doc["battery"] = getBatteryLevel(); // Implement battery reading if applicable
  String payload;
  serializeJson(doc, payload);
  sendToServer(keepaliveServerUrl, payload);
  addLogEntry("KeepAlive sent.");
}

void addLogEntry(const String &entry) {
    // (wie gehabt)
  unsigned long ms = millis();
  String newLine = "[T=" + String(ms) + "] " + entry + "\n";
  logsBuffer += newLine;
  Serial.println("[LOG] " + entry);
  const size_t MAX_LOG_BUFFER_SIZE = 2048;
  if (logsBuffer.length() > MAX_LOG_BUFFER_SIZE) {
     int firstNewline = logsBuffer.indexOf('\n');
     if (firstNewline != -1) { logsBuffer = logsBuffer.substring(firstNewline + 1); }
     if (!logsBuffer.startsWith("[LOG_TRIMMED]")) { logsBuffer = "[LOG_TRIMMED] Log buffer size exceeded, older entries removed.\n" + logsBuffer; Serial.println("[LOG] Log buffer trimmed."); }
  }
}


void sendLogs() {
    // --- KORREKTUR: Fehlenden Code in der while-Schleife wiederherstellen ---
  if (logsBuffer.length() == 0) return;
  if (WiFi.status() != WL_CONNECTED) { Serial.println("[LOG] Kein WLAN, Logs können nicht gesendet werden."); return; }
  String mac = preferences.getString("mac_address", "Unbekannt");
  if (mac == "Unbekannt") { addLogEntry("Cannot send Logs, MAC address unknown."); return; }
  DynamicJsonDocument doc(logsBuffer.length() + 512);
  doc["mac_address"] = mac;
  JsonArray logsArray = doc.createNestedArray("logs");

  // --- KORRIGIERTE while-Schleife ---
  int startIndex = 0;
  int endIndex = -1;
  while (startIndex < logsBuffer.length()) {
    endIndex = logsBuffer.indexOf('\n', startIndex);
    String line; // Variable 'line' deklarieren
    if (endIndex == -1) {
      line = logsBuffer.substring(startIndex);
      startIndex = logsBuffer.length();
    } else {
      line = logsBuffer.substring(startIndex, endIndex);
      startIndex = endIndex + 1;
    }
    line.trim();
    if (line.length() > 0) {
      logsArray.add(line);
    }
  }
  // --- Ende korrigierte Schleife ---

  if (logsArray.size() == 0) { Serial.println("[LOG] Nach dem Parsen keine gültigen Log-Zeilen zum Senden."); logsBuffer = ""; return; }

  String payload;
  serializeJson(doc, payload);
  Serial.printf("[LOG] Sende %d Log-Zeilen an Server -> /logs\n", logsArray.size());
  HTTPClient logHttp;
  if (!logHttp.begin(secureClient, logsServerUrl)) { addLogEntry("HTTPS begin failed for /logs"); return; }
  logHttp.addHeader("Content-Type", "application/json");
  logHttp.setTimeout(10000);
  int code = logHttp.POST(payload);
  if (code >= 200 && code < 300) { Serial.printf("[HTTPS] Logs gesendet, Code: %d\n", code); logsBuffer = ""; }
  else { Serial.printf("[HTTPS][ERROR] Fehler Logs. Code: %d %s\n", code, logHttp.errorToString(code).c_str()); addLogEntry("Failed to send logs. Code: " + String(code)); }
  logHttp.end();
}


void configureDeepSleep() {
    // (wie gehabt)
  Serial.println("[DEEPSLEEP] Konfiguriere Deep Sleep...");
  esp_err_t ext0_result = esp_sleep_enable_ext0_wakeup(GPIO_NUM_27, 1);
  if (ext0_result != ESP_OK) { Serial.printf("[DEEPSLEEP][ERROR] Konnte EXT0 nicht konfigurieren: %s\n", esp_err_to_name(ext0_result)); addLogEntry("Failed to configure EXT0 wakeup: " + String(esp_err_to_name(ext0_result)));} else { Serial.println("[DEEPSLEEP] EXT0 Wakeup auf GPIO 27 (HIGH) aktiviert."); }
  uint64_t sleepTimeUs = (uint64_t)keepAliveInterval * 1000ULL;
  esp_err_t timer_result = esp_sleep_enable_timer_wakeup(sleepTimeUs);
  if (timer_result != ESP_OK) { Serial.printf("[DEEPSLEEP][ERROR] Konnte Timer nicht konfigurieren: %s\n", esp_err_to_name(timer_result)); addLogEntry("Failed to configure Timer wakeup: " + String(esp_err_to_name(timer_result))); } else { Serial.printf("[DEEPSLEEP] Timer Wakeup in %lu ms aktiviert.\n", keepAliveInterval); }
  Serial.println("[DEEPSLEEP] Gehe jetzt schlafen...");
  Serial.flush();
  delay(100);
  esp_deep_sleep_start();
  Serial.println("[DEEPSLEEP] Dieser Text sollte NIE erscheinen!");
}
